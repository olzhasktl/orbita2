# 1 "c:/Marmalade/7.5/examples/GameTutorial/CPP/Stage4/source/timer.cpp"
# 1 "c:\\Marmalade\\7.5\\examples\\GameTutorial\\CPP\\Stage4\\build_stage4_vc12//"
# 1 "<command-line>"
# 1 "c:/Marmalade/7.5/examples/GameTutorial/CPP/Stage4/build_stage4_vc12/temp_defines_debug.h" 1
# 1 "<command-line>" 2
# 1 "c:/Marmalade/7.5/examples/GameTutorial/CPP/Stage4/source/timer.cpp"
# 13 "c:/Marmalade/7.5/examples/GameTutorial/CPP/Stage4/source/timer.cpp"
# 1 "c:/Marmalade/7.5/examples/GameTutorial/CPP/Stage4/source/timer.h" 1
# 16 "c:/Marmalade/7.5/examples/GameTutorial/CPP/Stage4/source/timer.h"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/list" 1
# 31 "c:/marmalade/7.5/s3e/h/std/c++/list"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_prolog.h" 1
# 10 "c:/marmalade/7.5/s3e/h/std/c++/stl/_prolog.h"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_config.h" 1
# 62 "c:/marmalade/7.5/s3e/h/std/c++/stl/_config.h"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl_user_config.h" 1
# 63 "c:/marmalade/7.5/s3e/h/std/c++/stl/_config.h" 2




# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_config_compat.h" 1
# 68 "c:/marmalade/7.5/s3e/h/std/c++/stl/_config.h" 2



# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_site_config.h" 1
# 72 "c:/marmalade/7.5/s3e/h/std/c++/stl/_config.h" 2


# 1 "c:/marmalade/7.5/s3e/h/std/c++/config/stlcomp.h" 1
# 54 "c:/marmalade/7.5/s3e/h/std/c++/config/stlcomp.h"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/config/stl_gcc_s3e.h" 1
# 67 "c:/marmalade/7.5/s3e/h/std/c++/config/stl_gcc_s3e.h"
     typedef char __stl_char;
# 55 "c:/marmalade/7.5/s3e/h/std/c++/config/stlcomp.h" 2
# 75 "c:/marmalade/7.5/s3e/h/std/c++/stl/_config.h" 2
# 83 "c:/marmalade/7.5/s3e/h/std/c++/stl/_config.h"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/config/stl_confix.h" 1
# 84 "c:/marmalade/7.5/s3e/h/std/c++/stl/_config.h" 2
# 488 "c:/marmalade/7.5/s3e/h/std/c++/stl/_config.h"
namespace std { }
namespace __std_alias = std;
# 546 "c:/marmalade/7.5/s3e/h/std/c++/stl/_config.h"
namespace _STL { }

namespace stlport = _STL;
# 11 "c:/marmalade/7.5/s3e/h/std/c++/stl/_prolog.h" 2





# 1 "c:/marmalade/7.5/s3e/h/std/c++/config/_prolog.h" 1
# 17 "c:/marmalade/7.5/s3e/h/std/c++/stl/_prolog.h" 2
# 32 "c:/marmalade/7.5/s3e/h/std/c++/list" 2



         



# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_list.h" 1
# 34 "c:/marmalade/7.5/s3e/h/std/c++/stl/_list.h"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_algobase.h" 1
# 35 "c:/marmalade/7.5/s3e/h/std/c++/stl/_algobase.h"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/cstddef" 1
# 37 "c:/marmalade/7.5/s3e/h/std/c++/cstddef"
# 1 "c:/marmalade/7.5/s3e/h/ext/../std/stddef.h" 1
# 19 "c:/marmalade/7.5/s3e/h/ext/../std/stddef.h"
typedef signed int ptrdiff_t;




    typedef unsigned int wint_t;
    typedef unsigned long int wctype_t;







typedef unsigned int size_t;
# 38 "c:/marmalade/7.5/s3e/h/std/c++/cstddef" 2



namespace _STL {
using ::ptrdiff_t;
using ::size_t;
}
# 36 "c:/marmalade/7.5/s3e/h/std/c++/stl/_algobase.h" 2



# 1 "c:/marmalade/7.5/s3e/h/std/c++/cstring" 1
# 27 "c:/marmalade/7.5/s3e/h/std/c++/cstring"
# 1 "c:/marmalade/7.5/s3e/h/ext/../std/string.h" 1
# 15 "c:/marmalade/7.5/s3e/h/ext/../std/string.h"
# 1 "c:/marmalade/7.5/s3e/h/std/sys/types.h" 1
# 15 "c:/marmalade/7.5/s3e/h/std/sys/types.h"
# 1 "c:/marmalade/7.5/s3e/h/s3eTypes.h" 1
# 35 "c:/marmalade/7.5/s3e/h/s3eTypes.h"
typedef unsigned char s3e_uint8_t;
typedef signed char s3e_int8_t;
typedef unsigned short int s3e_uint16_t;
typedef signed short int s3e_int16_t;
typedef unsigned int s3e_uint32_t;
typedef signed int s3e_int32_t;







typedef unsigned long long s3e_uint64_t;
typedef signed long long s3e_int64_t;






typedef unsigned long s3e_size_t;
typedef long int s3e_ssize_t;
# 74 "c:/marmalade/7.5/s3e/h/s3eTypes.h"
typedef s3e_uint64_t uint64_t;
typedef s3e_int64_t int64_t;
typedef s3e_uint32_t uint32_t;
typedef s3e_int32_t int32_t;
typedef s3e_uint16_t uint16_t;
typedef s3e_int16_t int16_t;
typedef s3e_uint8_t uint8_t;
typedef s3e_int8_t int8_t;
# 96 "c:/marmalade/7.5/s3e/h/s3eTypes.h"
    typedef int intptr_t;
    typedef unsigned int uintptr_t;
# 123 "c:/marmalade/7.5/s3e/h/s3eTypes.h"
typedef unsigned int uint;
typedef unsigned short int ushort;
typedef unsigned long int ulong;
typedef unsigned char uint8;
typedef signed char int8;


typedef int64_t int64;
typedef uint64_t uint64;




typedef unsigned int uint32;






typedef signed int int32;






typedef uint16_t uint16;




typedef int16_t int16;
# 234 "c:/marmalade/7.5/s3e/h/s3eTypes.h"
typedef enum s3eResult
{
    S3E_RESULT_SUCCESS = 0,
    S3E_RESULT_ERROR = 1
} s3eResult;




typedef uint8 s3eBool;
# 252 "c:/marmalade/7.5/s3e/h/s3eTypes.h"
typedef wchar_t s3eWChar;
# 264 "c:/marmalade/7.5/s3e/h/s3eTypes.h"
typedef int32 (*s3eCallback) (void* systemData, void* userData);
# 16 "c:/marmalade/7.5/s3e/h/std/sys/types.h" 2
# 1 "c:/marmalade/7.5/s3e/h/std/stddef.h" 1
# 17 "c:/marmalade/7.5/s3e/h/std/sys/types.h" 2
# 1 "c:/marmalade/7.5/s3e/h/std/stdint.h" 1
# 19 "c:/marmalade/7.5/s3e/h/std/stdint.h"
typedef signed char int_least8_t;
typedef short int_least16_t;
typedef long int_least32_t;
typedef int64_t int_least64_t;

typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned long uint_least32_t;
typedef uint64_t uint_least64_t;

typedef signed char int_fast8_t;
typedef short int_fast16_t;
typedef long int_fast32_t;
typedef int64_t int_fast64_t;

typedef unsigned char uint_fast8_t;
typedef unsigned short uint_fast16_t;
typedef unsigned long uint_fast32_t;
typedef uint64_t uint_fast64_t;

typedef int64_t intmax_t;
typedef uint64_t uintmax_t;
# 18 "c:/marmalade/7.5/s3e/h/std/sys/types.h" 2
# 1 "c:/marmalade/7.5/s3e/h/std/sys/select.h" 1
# 24 "c:/marmalade/7.5/s3e/h/std/sys/select.h"
struct timeval;

typedef struct fd_set
{
    char fds_bits[256/8];
} fd_set;
# 39 "c:/marmalade/7.5/s3e/h/std/sys/select.h"
extern "C" {

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);

}
# 19 "c:/marmalade/7.5/s3e/h/std/sys/types.h" 2



typedef long off_t;

typedef int64_t off64_t;


namespace std
{
typedef ::size_t size_t;
}


typedef uint u_int;
typedef uint8_t u_int8_t;
typedef uint16_t u_int16_t;
typedef uint32_t u_int32_t;
typedef uint64_t u_int64_t;

typedef unsigned short u_short;
typedef unsigned long u_long;
typedef unsigned char u_char;




typedef int ssize_t;

typedef int pid_t;
typedef short uid_t;
typedef short gid_t;
typedef int idtype_t;
typedef int id_t;
typedef uint32 mode_t;
typedef short dev_t;
typedef short ino_t;
typedef int key_t;
typedef void* caddr_t;
# 16 "c:/marmalade/7.5/s3e/h/ext/../std/string.h" 2

extern "C" {

void *memcpy(void *dest, const void *src, size_t n);
void *memset(void *s, int c, size_t n);
int memcmp(const void *s1, const void *s2, size_t n);
void *memmove(void *dest, const void *src, size_t n);
void *memchr(const void *s, int c, size_t n);
void *memrchr(const void *s, int c, size_t n);
# 34 "c:/marmalade/7.5/s3e/h/ext/../std/string.h"
int strcmp(const char *s1, const char *s2);
int strncmp(const char *s1, const char *s2, size_t n);
char *strsep(char **stringp, const char *delim);
char *strcpy(char *dest, const char *src);
char *strncpy(char *dest, const char *src, size_t n);
char *strchr(const char *s, int c);
char *strstr(const char *haystack, const char *needle);
char *strrchr(const char *s, int c);
char *strdup(const char *s);
char *strtok(char *str, const char *delim);
char *strtok_r(char *str, const char *delim, char **saveptr);
char *strcat(char *dest, const char *src);
char *strncat(char *dest, const char *src, size_t n);
size_t strlen(const char *s);
size_t strnlen(const char *s, size_t n);
int strcasecmp(const char *s1, const char *s2);
int strncasecmp(const char *s1, const char *s2, size_t n);
size_t strspn(const char *s, const char *accept);
size_t strcspn(const char *s, const char *reject);
char *strpbrk(const char *s, const char *accept);
int strcoll(const char *s1, const char *s2);
char *strerror(int errnum);
size_t strxfrm(char *dest, const char *src, size_t n);

int strerror_r(int errnum, char *buf, size_t buflen);





size_t strlcpy(char* dest, const char* src, size_t len);
size_t strlcat(char* dest, const char* src, size_t len);

char* strnstr(const char *s, const char *find, size_t slen);

}
# 28 "c:/marmalade/7.5/s3e/h/std/c++/cstring" 2



namespace _STL {
# 1 "c:/marmalade/7.5/s3e/h/std/c++/using/cstring" 1
using ::size_t;
# 17 "c:/marmalade/7.5/s3e/h/std/c++/using/cstring"
 using ::memmove;
 using ::memcpy;




using ::memchr;
using ::strchr;
using ::strpbrk;
using ::strrchr;
using ::strstr;


using ::memcmp;
using ::memset;

using ::strcat;


using ::strcmp;


using ::strcoll;

using ::strcpy;

using ::strcspn;
using ::strerror;
using ::strlen;
using ::strncat;
using ::strncmp;

using ::strncpy;
using ::strspn;

using ::strtok;
using ::strxfrm;
# 33 "c:/marmalade/7.5/s3e/h/std/c++/cstring" 2
}
# 40 "c:/marmalade/7.5/s3e/h/std/c++/stl/_algobase.h" 2



# 1 "c:/marmalade/7.5/s3e/h/std/c++/climits" 1
# 32 "c:/marmalade/7.5/s3e/h/std/c++/climits"
# 1 "c:/marmalade/7.5/s3e/h/std/limits.h" 1
# 33 "c:/marmalade/7.5/s3e/h/std/c++/climits" 2
# 44 "c:/marmalade/7.5/s3e/h/std/c++/stl/_algobase.h" 2



# 1 "c:/marmalade/7.5/s3e/h/std/c++/cstdlib" 1
# 27 "c:/marmalade/7.5/s3e/h/std/c++/cstdlib"
# 1 "c:/marmalade/7.5/s3e/h/ext/../std/stdlib.h" 1
# 16 "c:/marmalade/7.5/s3e/h/ext/../std/stdlib.h"
# 1 "c:/marmalade/7.5/s3e/h/std/malloc.h" 1
# 16 "c:/marmalade/7.5/s3e/h/std/malloc.h"
# 1 "c:/marmalade/7.5/s3e/h/std/alloca.h" 1
# 17 "c:/marmalade/7.5/s3e/h/std/alloca.h"
extern "C" {






    extern void *alloca(size_t __size);
# 39 "c:/marmalade/7.5/s3e/h/std/alloca.h"
}
# 17 "c:/marmalade/7.5/s3e/h/std/malloc.h" 2

extern "C" {

void *calloc(size_t nmemb, size_t size);
void *malloc(size_t size);
void free(void *ptr);
void *realloc(void *ptr, size_t size);

}
# 17 "c:/marmalade/7.5/s3e/h/ext/../std/stdlib.h" 2
# 28 "c:/marmalade/7.5/s3e/h/ext/../std/stdlib.h"
extern "C" {

double atof(const char* string);
int atoi(const char *nptr);
long atol(const char *nptr);
int64_t atoll(const char *nptr);
int64_t atoq(const char *nptr);
int abs(int j);
long int labs(long int j);
int64_t llabs(int64_t j);
void qsort(void *base, size_t nmemb, size_t size, int(*compar)(const void *, const void *));
void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
void abort(void) __attribute__ ((noreturn));
int putenv(char *string);
char *getenv(const char *name);
int setenv(const char *name, const char *value, int overwrite);
int unsetenv(const char *name);
void exit(int status) __attribute__ ((noreturn));
void _exit(int status) __attribute__ ((noreturn));
void _Exit(int status) __attribute__ ((noreturn));
unsigned long int strtoul(const char *nptr, char **endptr, int base);
uint64_t strtoull(const char *nptr, char **endptr, int base);
long int strtol(const char *nptr, char **endptr, int base);
int64_t strtoll(const char *nptr, char **endptr, int base);
double strtod(const char *nptr, char **endptr);
float strtof(const char *nptr, char **endptr);
long double strtold(const char *nptr, char **endptr);
int atexit(void (*function)(void));
int system(const char *command);
int posix_memalign(void **memptr, size_t alignment, size_t size);
char *mktemp(char *templ);
int mkstemp(char *templ);



int rand(void);
void srand(unsigned int seed);

long int random(void);
void srandom(unsigned int seed);

size_t __ctype_get_mb_cur_max();


int mblen(const char *s, size_t n);
int mbtowc(wchar_t *pwc, const char *s, size_t n);
int wctomb(char *s, wchar_t wc);
size_t mbstowcs(wchar_t *dest, const char *src, size_t n);
size_t wcstombs(char *dest, const wchar_t *src, size_t n);

typedef struct
{
    int quot;
    int rem;
} div_t;

typedef struct
{
    int quot;
    int rem;
} ldiv_t;

typedef struct
{
    int64_t quot;
    int64_t rem;
} lldiv_t;

div_t div(int numerator, int denominator);
ldiv_t ldiv(long numerator, long denominator);
lldiv_t lldiv(int64_t numerator, int64_t denominator);
# 118 "c:/marmalade/7.5/s3e/h/ext/../std/stdlib.h"
}
# 28 "c:/marmalade/7.5/s3e/h/std/c++/cstdlib" 2
# 41 "c:/marmalade/7.5/s3e/h/std/c++/cstdlib"
namespace _STL {
using ::div_t;
using ::ldiv_t;
using ::size_t;


using ::abort;
using ::atexit;
using ::exit;
using ::getenv;
using ::calloc;
using ::free;
using ::malloc;
using ::realloc;
using ::atof;
using ::atoi;
using ::atol;
using ::mblen;
using ::mbstowcs;
using ::mbtowc;
using ::strtod;
using ::strtol;
using ::strtoul;
using ::system;


using ::wcstombs;
using ::wctomb;

using ::bsearch;
using ::qsort;




using ::div;
using ::labs;
using ::ldiv;
using ::rand;
using ::srand;

}


namespace _STL {



inline long abs(long __x) { return ::labs(__x); }


inline ldiv_t div(long __x, long __y) { return ::ldiv(__x, __y); }
# 103 "c:/marmalade/7.5/s3e/h/std/c++/cstdlib"
}
# 48 "c:/marmalade/7.5/s3e/h/std/c++/stl/_algobase.h" 2



# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_pair.h" 1
# 34 "c:/marmalade/7.5/s3e/h/std/c++/stl/_pair.h"
namespace _STL {

template <class _T1, class _T2>
struct pair {
  typedef _T1 first_type;
  typedef _T2 second_type;

  _T1 first;
  _T2 second;



  pair() : first(_T1()), second(_T2()) {}

  pair(const _T1& __a, const _T2& __b) : first(__a), second(__b) {}


  template <class _U1, class _U2>
  pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}

  pair(const pair<_T1,_T2>& __o) : first(__o.first), second(__o.second) {}

 
};

template <class _T1, class _T2>
inline bool operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{
  return __x.first == __y.first && __x.second == __y.second;
}

template <class _T1, class _T2>
inline bool operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{
  return __x.first < __y.first ||
         (!(__y.first < __x.first) && __x.second < __y.second);
}



template <class _T1, class _T2>
inline bool operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__x == __y);
}

template <class _T1, class _T2>
inline bool operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return __y < __x;
}

template <class _T1, class _T2>
inline bool operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__y < __x);
}

template <class _T1, class _T2>
inline bool operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__x < __y);
}





template <class _T1, class _T2, int _Sz>
inline pair<_T1, _T2 const*> make_pair(_T1 const& __x,
                                       _T2 const (&__y)[_Sz])
{
  return pair<_T1, _T2 const*>(__x, static_cast<_T2 const*>(__y));
}

template <class _T1, class _T2, int _Sz>
inline pair<_T1 const*, _T2> make_pair(_T1 const (&__x)[_Sz],
                                       _T2 const& __y)
{
  return pair<_T1 const*, _T2>(static_cast<_T1 const*>(__x), __y);
}

template <class _T1, class _T2, int _Sz1, int _Sz2>
inline pair<_T1 const*, _T2 const*> make_pair(_T1 const (&__x)[_Sz1],
                                              _T2 const (&__y)[_Sz2])
{
  return pair<_T1 const*, _T2 const*>(static_cast<_T1 const*>(__x),
                                      static_cast<_T2 const*>(__y));
}


template <class _T1, class _T2>
inline pair<_T1, _T2> make_pair(const _T1& __x, const _T2& __y)
{
  return pair<_T1, _T2>(__x, __y);
}


}


namespace _STL { namespace rel_ops {

template <class _Tp>
inline bool operator!=(const _Tp& __x, const _Tp& __y) {
  return !(__x == __y);
}

template <class _Tp>
inline bool operator>(const _Tp& __x, const _Tp& __y) {
  return __y < __x;
}

template <class _Tp>
inline bool operator<=(const _Tp& __x, const _Tp& __y) {
  return !(__y < __x);
}

template <class _Tp>
inline bool operator>=(const _Tp& __x, const _Tp& __y) {
  return !(__x < __y);
}

} }
# 52 "c:/marmalade/7.5/s3e/h/std/c++/stl/_algobase.h" 2



# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_iterator_base.h" 1
# 44 "c:/marmalade/7.5/s3e/h/std/c++/stl/_iterator_base.h"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/type_traits.h" 1
# 62 "c:/marmalade/7.5/s3e/h/std/c++/stl/type_traits.h"
namespace _STL {

struct __true_type {};
struct __false_type {};


template <int _Is> struct __bool2type {
  typedef __false_type _Ret;
};

template<>
struct __bool2type<1> { typedef __true_type _Ret; };

template<>
struct __bool2type<0> { typedef __false_type _Ret; };


template <class _P1, class _P2, class _P3>
struct _Land3 {
  typedef __false_type _Ret;
};

template<>
struct _Land3<__true_type, __true_type, __true_type> {
  typedef __true_type _Ret;
};



template <class _Tp> struct __type_traits;
template <int _IsPOD> struct __type_traits_aux {
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};

template<>
struct __type_traits_aux<0> {
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};

template<>
struct __type_traits_aux<1> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};
# 188 "c:/marmalade/7.5/s3e/h/std/c++/stl/type_traits.h"
template <class _Tp>
struct __type_traits {
   typedef __true_type this_dummy_member_must_be_first;
# 206 "c:/marmalade/7.5/s3e/h/std/c++/stl/type_traits.h"
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};


template <class _Tp> struct _IsPtr { enum { _Ret = 0 }; };
template <class _Tp> struct _IsPtrType {
  static __false_type _Ret() { return __false_type();}
};
template <class _Tp1, class _Tp2> struct _BothPtrType {
  static __false_type _Ret() { return __false_type();}
};

template <class _Tp1, class _Tp2>
struct _IsSame { enum { _Ret = 0 }; };





template <class _Tp> struct _IsPtr<_Tp*> { enum { _Ret = 1 }; };
template <class _Tp> struct _IsPtrType<_Tp*> {
  static __true_type _Ret() { return __true_type();}
};
template <class _Tp1, class _Tp2> struct _BothPtrType<_Tp1*, _Tp2*> {
  static __true_type _Ret() { return __true_type();}
};
template <class _Tp>
struct _IsSame<_Tp, _Tp> { enum { _Ret = 1 }; };
# 246 "c:/marmalade/7.5/s3e/h/std/c++/stl/type_traits.h"
template<> struct __type_traits<bool> : __type_traits_aux<1> {};

template<> struct __type_traits<char> : __type_traits_aux<1> {};

template<> struct __type_traits<signed char> : __type_traits_aux<1> {};

template<> struct __type_traits<unsigned char> : __type_traits_aux<1> {};




template<> struct __type_traits<short> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned short> : __type_traits_aux<1> {};
template<> struct __type_traits<int> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned int> : __type_traits_aux<1> {};
template<> struct __type_traits<long> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned long> : __type_traits_aux<1> {};


template<> struct __type_traits<long long> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned long long> : __type_traits_aux<1> {};


template<> struct __type_traits<float> : __type_traits_aux<1> {};
template<> struct __type_traits<double> : __type_traits_aux<1> {};


template<> struct __type_traits<long double> : __type_traits_aux<1> {};



template <class _Tp> struct __type_traits<_Tp*> : __type_traits_aux<1> {};





template <class _Tp> struct _Is_integer {
  typedef __false_type _Integral;
};



template<> struct _Is_integer<bool> {
  typedef __true_type _Integral;
};



template<> struct _Is_integer<char> {
  typedef __true_type _Integral;
};



template<> struct _Is_integer<signed char> {
  typedef __true_type _Integral;
};


template<> struct _Is_integer<unsigned char> {
  typedef __true_type _Integral;
};
# 318 "c:/marmalade/7.5/s3e/h/std/c++/stl/type_traits.h"
template<> struct _Is_integer<short> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned short> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<int> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned int> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned long> {
  typedef __true_type _Integral;
};



template<> struct _Is_integer<long long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned long long> {
  typedef __true_type _Integral;
};



template <class _Tp1, class _Tp2>
struct _OKToMemCpy {
  enum { _Same = _IsSame<_Tp1,_Tp2>::_Ret } ;
  typedef typename __type_traits<_Tp1>::has_trivial_assignment_operator _Tr1;
  typedef typename __type_traits<_Tp2>::has_trivial_assignment_operator _Tr2;
  typedef typename __bool2type< _Same >::_Ret _Tr3;
  typedef typename _Land3<_Tr1, _Tr2, _Tr3>::_Ret _Type;
  static _Type _Ret() { return _Type(); }
};

template <class _Tp1, class _Tp2>
inline _OKToMemCpy<_Tp1, _Tp2> _IsOKToMemCpy(_Tp1*, _Tp2*) {
  return _OKToMemCpy<_Tp1, _Tp2>();
}

template <class _Tp>
struct _IsPOD {
  typedef typename __type_traits<_Tp>::is_POD_type _Type;
  static _Type _Ret() { return _Type(); }
};

template <class _Tp>
inline _IsPOD<_Tp> _Is_POD (_Tp*) { return _IsPOD<_Tp>(); }
# 411 "c:/marmalade/7.5/s3e/h/std/c++/stl/type_traits.h"
}
# 45 "c:/marmalade/7.5/s3e/h/std/c++/stl/_iterator_base.h" 2


namespace _STL {

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};


template <class _Category, class _Tp, class _Distance = ptrdiff_t,
          class _Pointer = _Tp*, class _Reference = _Tp& >
struct iterator {
  typedef _Category iterator_category;
  typedef _Tp value_type;
  typedef _Distance difference_type;
  typedef _Pointer pointer;
  typedef _Reference reference;
};
template<>
struct iterator<output_iterator_tag, void, void, void, void> {
  typedef output_iterator_tag iterator_category;

  typedef void value_type;
  typedef void difference_type;
  typedef void pointer;
  typedef void reference;

};
# 96 "c:/marmalade/7.5/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Iterator>
struct iterator_traits {
  typedef typename _Iterator::iterator_category iterator_category;
  typedef typename _Iterator::value_type value_type;
  typedef typename _Iterator::difference_type difference_type;
  typedef typename _Iterator::pointer pointer;
  typedef typename _Iterator::reference reference;
};
# 115 "c:/marmalade/7.5/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Tp>
struct iterator_traits<const _Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef ptrdiff_t difference_type;
  typedef const _Tp* pointer;
  typedef const _Tp& reference;
};

template <class _Tp>
struct iterator_traits<_Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef ptrdiff_t difference_type;
  typedef _Tp* pointer;
  typedef _Tp& reference;
};
# 164 "c:/marmalade/7.5/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Iter>
inline typename iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter&) {
  typedef typename iterator_traits<_Iter>::iterator_category _Category;
  return _Category();
}

template <class _Iter>
inline typename iterator_traits<_Iter>::difference_type* __distance_type(const _Iter&) {
  typedef typename iterator_traits<_Iter>::difference_type _diff_type;
  return static_cast<_diff_type*>(0);
}

template <class _Iter>
inline typename iterator_traits<_Iter>::value_type* __value_type(const _Iter&) {
  typedef typename iterator_traits<_Iter>::value_type _value_type;
  return static_cast<_value_type*>(0);
}
# 236 "c:/marmalade/7.5/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Tp, class _Distance> struct input_iterator :
  public iterator <input_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
struct output_iterator : public iterator <output_iterator_tag, void, void, void, void> {};
template <class _Tp, class _Distance> struct forward_iterator :
  public iterator<forward_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
template <class _Tp, class _Distance> struct bidirectional_iterator :
  public iterator<bidirectional_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
template <class _Tp, class _Distance> struct random_access_iterator :
  public iterator<random_access_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
# 281 "c:/marmalade/7.5/s3e/h/std/c++/stl/_iterator_base.h"
template <class _InputIterator, class _Distance>
inline void __distance(const _InputIterator& __first, const _InputIterator& __last,
      _Distance& __n, const input_iterator_tag &) {
  _InputIterator __it(__first);
  while (__it != __last) { ++__it; ++__n; }
}
# 305 "c:/marmalade/7.5/s3e/h/std/c++/stl/_iterator_base.h"
template <class _RandomAccessIterator, class _Distance>
inline void __distance(const _RandomAccessIterator& __first,
      const _RandomAccessIterator& __last,
      _Distance& __n, const random_access_iterator_tag &) {
  __n += __last - __first;
}


template <class _InputIterator, class _Distance>
inline void distance(const _InputIterator& __first,
    const _InputIterator& __last, _Distance& __n) {
  __distance(__first, __last, __n, typename iterator_traits< _InputIterator >::iterator_category());
}


template <class _InputIterator>
inline typename iterator_traits<_InputIterator>::difference_type
__distance(const _InputIterator& __first, const _InputIterator& __last, const input_iterator_tag &) {
  typename iterator_traits<_InputIterator>::difference_type __n = 0;
  _InputIterator __it(__first);
  while (__it != __last) {
    ++__it; ++__n;
  }
  return __n;
}
# 359 "c:/marmalade/7.5/s3e/h/std/c++/stl/_iterator_base.h"
template <class _RandomAccessIterator>
inline typename iterator_traits<_RandomAccessIterator>::difference_type
__distance(const _RandomAccessIterator& __first, const _RandomAccessIterator& __last,
           const random_access_iterator_tag &) {
  return __last - __first;
}

template <class _InputIterator>
inline typename iterator_traits<_InputIterator>::difference_type
distance(const _InputIterator& __first, const _InputIterator& __last) {
  return __distance(__first, __last, typename iterator_traits< _InputIterator >::iterator_category());
}



template <class _Tp>
struct _Nonconst_traits;

template <class _Tp>
struct _Const_traits {
  typedef _Tp value_type;
  typedef const _Tp& reference;
  typedef const _Tp* pointer;
  typedef _Nonconst_traits<_Tp> _Non_const_traits;
};

template <class _Tp>
struct _Nonconst_traits {
  typedef _Tp value_type;
  typedef _Tp& reference;
  typedef _Tp* pointer;
  typedef _Nonconst_traits<_Tp> _Non_const_traits;
};
# 414 "c:/marmalade/7.5/s3e/h/std/c++/stl/_iterator_base.h"
template <class _InputIter, class _Distance>
inline void __advance(_InputIter& __i, _Distance __n, const input_iterator_tag &) {
  while (__n--) ++__i;
}


template <class _InputIter, class _Distance>
inline void __advance(_InputIter& __i, _Distance __n, const output_iterator_tag &) {
  while (__n--) ++__i;
}
# 432 "c:/marmalade/7.5/s3e/h/std/c++/stl/_iterator_base.h"
template <class _BidirectionalIterator, class _Distance>
inline void __advance(_BidirectionalIterator& __i, _Distance __n,
                      const bidirectional_iterator_tag &) {
  if (__n > 0)
    while (__n--) ++__i;
  else
    while (__n++) --__i;
}

template <class _RandomAccessIterator, class _Distance>
inline void __advance(_RandomAccessIterator& __i, _Distance __n,
                      const random_access_iterator_tag &) {
  __i += __n;
}

template <class _InputIterator, class _Distance>
inline void advance(_InputIterator& __i, _Distance __n) {
  __advance(__i, __n, typename iterator_traits< _InputIterator >::iterator_category());
}

}
# 56 "c:/marmalade/7.5/s3e/h/std/c++/stl/_algobase.h" 2


namespace _STL {

template <class _Tp>
inline void swap(_Tp& __a, _Tp& __b) {
  _Tp __tmp = __a;
  __a = __b;
  __b = __tmp;
}

template <class _ForwardIter1, class _ForwardIter2>
inline void iter_swap(_ForwardIter1 __i1, _ForwardIter2 __i2) {
  swap(*__i1, *__i2);
}





template <class _Tp>
inline const _Tp& (min)(const _Tp& __a, const _Tp& __b) { return __b < __a ? __b : __a; }
template <class _Tp>
inline const _Tp& (max)(const _Tp& __a, const _Tp& __b) { return __a < __b ? __b : __a; }







template <class _Tp, class _Compare>
inline const _Tp& (min)(const _Tp& __a, const _Tp& __b, _Compare __comp) {
  return __comp(__b, __a) ? __b : __a;
}

template <class _Tp, class _Compare>
inline const _Tp& (max)(const _Tp& __a, const _Tp& __b, _Compare __comp) {
  return __comp(__a, __b) ? __b : __a;
}
# 106 "c:/marmalade/7.5/s3e/h/std/c++/stl/_algobase.h"
template <class _InputIter, class _OutputIter, class _Distance>
inline _OutputIter __copy(_InputIter __first, _InputIter __last,
                          _OutputIter __result,
                          const input_iterator_tag &, _Distance*) {
  for ( ; __first != __last; ++__result, ++__first)
    *__result = *__first;
  return __result;
}
# 134 "c:/marmalade/7.5/s3e/h/std/c++/stl/_algobase.h"
template <class _RandomAccessIter, class _OutputIter, class _Distance>
inline _OutputIter
__copy(_RandomAccessIter __first, _RandomAccessIter __last,
       _OutputIter __result, const random_access_iterator_tag &, _Distance*) {
  for (_Distance __n = __last - __first; __n > 0; --__n) {
    *__result = *__first;
    ++__first;
    ++__result;
  }
  return __result;
}

inline void*
__copy_trivial(const void* __first, const void* __last, void* __result) {
  return (__last == __first) ? __result :
    ((char*)memmove(__result, __first, ((const char*)__last - (const char*)__first))) +
    ((const char*)__last - (const char*)__first);
}




template <class _BidirectionalIter1, class _BidirectionalIter2,
          class _Distance>
inline _BidirectionalIter2 __copy_backward(_BidirectionalIter1 __first,
                                           _BidirectionalIter1 __last,
                                           _BidirectionalIter2 __result,
                                           const bidirectional_iterator_tag &,
                                           _Distance*)
{
  while (__first != __last)
    *--__result = *--__last;
  return __result;
}

template <class _RandomAccessIter, class _BidirectionalIter, class _Distance>
inline _BidirectionalIter __copy_backward(_RandomAccessIter __first,
                                          _RandomAccessIter __last,
                                          _BidirectionalIter __result,
                                          const random_access_iterator_tag &,
                                          _Distance*)
{
  for (_Distance __n = __last - __first; __n > 0; --__n)
    *--__result = *--__last;
  return __result;
}

inline void*
__copy_trivial_backward(const void* __first, const void* __last, void* __result) {
  const ptrdiff_t _Num = (const char*)__last - (const char*)__first;
  return (_Num > 0) ? memmove((char*)__result - _Num, __first, _Num) : __result ;
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy(__first, __last, __result,
                typename iterator_traits< _InputIter >::iterator_category(),
                (typename iterator_traits< _InputIter >::difference_type*)0);
}
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {


  return (_OutputIter)__copy_trivial(__first, __last, __result);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
  return __copy_ptrs(__first, __last, __result,
                     _IsOKToMemCpy((typename iterator_traits< _InputIter >::value_type*)0,
                                   (typename iterator_traits< _OutputIter >::value_type*)0)._Ret());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy(__first, __last, __result,
  typename iterator_traits< _InputIter >::iterator_category(), (typename iterator_traits< _InputIter >::difference_type*)0);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter copy(_InputIter __first, _InputIter __last, _OutputIter __result) {
 
    return __copy_aux(__first, __last, __result, _BothPtrType< _InputIter, _OutputIter> :: _Ret());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy_backward(__first, __last, __result, typename iterator_traits< _InputIter >::iterator_category(), (typename iterator_traits< _InputIter >::difference_type*)0);
}
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
  return (_OutputIter)__copy_trivial_backward(__first, __last, __result);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy_backward(__first, __last, __result, typename iterator_traits< _InputIter >::iterator_category(), (typename iterator_traits< _InputIter >::difference_type*)0);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
  return __copy_backward_ptrs(__first, __last, __result,
                              _IsOKToMemCpy((typename iterator_traits< _InputIter >::value_type*)0,
                                            (typename iterator_traits< _OutputIter >::value_type*)0)._Ret());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter copy_backward(_InputIter __first, _InputIter __last, _OutputIter __result) {
 
    return __copy_backward_aux(__first, __last, __result, _BothPtrType< _InputIter, _OutputIter> :: _Ret() );
}
# 282 "c:/marmalade/7.5/s3e/h/std/c++/stl/_algobase.h"
template <class _InputIter, class _Size, class _OutputIter>
inline
pair<_InputIter, _OutputIter> __copy_n(_InputIter __first, _Size __count,
                                       _OutputIter __result,
                                       const input_iterator_tag &) {
  for ( ; __count > 0; --__count) {
    *__result = *__first;
    ++__first;
    ++__result;
  }
  return pair<_InputIter, _OutputIter>(__first, __result);
}

template <class _RAIter, class _Size, class _OutputIter>
inline pair<_RAIter, _OutputIter>
__copy_n(_RAIter __first, _Size __count,
         _OutputIter __result,
         const random_access_iterator_tag &) {
  _RAIter __last = __first + __count;
  return pair<_RAIter, _OutputIter>(__last, copy(__first, __last, __result));
}

template <class _InputIter, class _Size, class _OutputIter>
inline pair<_InputIter, _OutputIter>
__copy_n(_InputIter __first, _Size __count, _OutputIter __result) {
 
  return __copy_n(__first, __count, __result, typename iterator_traits< _InputIter >::iterator_category());
}

template <class _InputIter, class _Size, class _OutputIter>
inline pair<_InputIter, _OutputIter>
copy_n(_InputIter __first, _Size __count, _OutputIter __result) {
 
  return __copy_n(__first, __count, __result, typename iterator_traits< _InputIter >::iterator_category());
}





template <class _ForwardIter, class _Tp>
inline
void fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {
 
  for ( ; __first != __last; ++__first)
    *__first = __val;
}

template <class _OutputIter, class _Size, class _Tp>
inline
_OutputIter fill_n(_OutputIter __first, _Size __n, const _Tp& __val) {
 
  for ( ; __n > 0; --__n, ++__first)
    *__first = __val;
  return __first;
}




inline void fill(unsigned char* __first, unsigned char* __last,
                 const unsigned char& __val) {
  unsigned char __tmp = __val;
  memset(__first, __tmp, __last - __first);
}

inline void fill(signed char* __first, signed char* __last,
                 const signed char& __val) {
  signed char __tmp = __val;
  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
}

inline void fill(char* __first, char* __last, const char& __val) {
  char __tmp = __val;
  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
}



template <class _Size>
inline unsigned char* fill_n(unsigned char* __first, _Size __n,
                             const unsigned char& __val) {
  fill(__first, __first + __n, __val);
  return __first + __n;
}

template <class _Size>
inline signed char* fill_n(char* __first, _Size __n,
                           const signed char& __val) {
  fill(__first, __first + __n, __val);
  return __first + __n;
}

template <class _Size>
inline char* fill_n(char* __first, _Size __n, const char& __val) {
  fill(__first, __first + __n, __val);
  return __first + __n;
}







template <class _InputIter1, class _InputIter2>
inline
pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
                                        _InputIter1 __last1,
                                        _InputIter2 __first2) {
 
 
  while (__first1 != __last1 && *__first1 == *__first2) {
    ++__first1;
    ++__first2;
  }
  return pair<_InputIter1, _InputIter2>(__first1, __first2);
}

template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
inline
pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
                                        _InputIter1 __last1,
                                        _InputIter2 __first2,
                                        _BinaryPredicate __binary_pred) {
 
 
  while (__first1 != __last1 && __binary_pred(*__first1, *__first2)) {
    ++__first1;
    ++__first2;
  }
  return pair<_InputIter1, _InputIter2>(__first1, __first2);
}

template <class _InputIter1, class _InputIter2>
inline
bool equal(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2) {
 
 
  for ( ; __first1 != __last1; ++__first1, ++__first2)
    if (!(*__first1 == *__first2))
      return false;
  return true;
}

template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
inline
bool equal(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2, _BinaryPredicate __binary_pred) {
 
 
  for ( ; __first1 != __last1; ++__first1, ++__first2)
    if (!__binary_pred(*__first1, *__first2))
      return false;
  return true;
}





template <class _InputIter1, class _InputIter2>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2);

template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _Compare __comp);

inline bool
lexicographical_compare(const unsigned char* __first1,
                        const unsigned char* __last1,
                        const unsigned char* __first2,
                        const unsigned char* __last2)
{
  const size_t __len1 = __last1 - __first1;
  const size_t __len2 = __last2 - __first2;
 
 

  const int __result = memcmp(__first1, __first2, (min) (__len1, __len2));
  return __result != 0 ? (__result < 0) : (__len1 < __len2);
}



inline bool lexicographical_compare(const char* __first1, const char* __last1,
                                    const char* __first2, const char* __last2)
{
 
 

  return lexicographical_compare((const unsigned char*) __first1,
                                 (const unsigned char*) __last1,
                                 (const unsigned char*) __first2,
                                 (const unsigned char*) __last2);
}


template <class _InputIter1, class _InputIter2>
int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _InputIter2 __last2);

inline int
__lexicographical_compare_3way(const unsigned char* __first1,
                               const unsigned char* __last1,
                               const unsigned char* __first2,
                               const unsigned char* __last2)
{
  const ptrdiff_t __len1 = __last1 - __first1;
  const ptrdiff_t __len2 = __last2 - __first2;
  const int __result = memcmp(__first1, __first2, (min) (__len1, __len2));
  return __result != 0 ? __result
                       : (__len1 == __len2 ? 0 : (__len1 < __len2 ? -1 : 1));
}



inline int
__lexicographical_compare_3way(const char* __first1, const char* __last1,
                               const char* __first2, const char* __last2)
{
  return __lexicographical_compare_3way((const unsigned char*) __first1,
                                        (const unsigned char*) __last1,
                                        (const unsigned char*) __first2,
                                        (const unsigned char*) __last2);
}




template <class _InputIter1, class _InputIter2>
int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                 _InputIter2 __first2, _InputIter2 __last2);




template <class _InputIter, class _Tp>
inline typename iterator_traits<_InputIter>::difference_type
count(_InputIter __first, _InputIter __last, const _Tp& __val) {
 
  typename iterator_traits<_InputIter>::difference_type __n = 0;
  for ( ; __first != __last; ++__first)
    if (*__first == __val)
      ++__n;
  return __n;
}


template <class _InputIter, class _Tp>
_InputIter find(_InputIter __first, _InputIter __last, const _Tp& __val);
template <class _InputIter, class _Predicate>
_InputIter find_if(_InputIter __first, _InputIter __last, _Predicate __pred);


template <class _ForwardIter1, class _ForwardIter2, class _BinaryPred>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2, _BinaryPred __predicate);


template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
_InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
                           _ForwardIter __first2, _ForwardIter __last2,
                           _BinaryPredicate __comp);

template <class _ForwardIter1, class _ForwardIter2,
          class _BinaryPredicate>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2,
         _BinaryPredicate __comp);


template <class _ForwardIter, class _Tp>
inline void
replace(_ForwardIter __first, _ForwardIter __last,
        const _Tp& __old_value, const _Tp& __new_value) {
 
  for ( ; __first != __last; ++__first)
    if (*__first == __old_value)
      *__first = __new_value;
}

template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
_ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last,
                              const _Tp& __val, const _Compare& __comp, _Distance*);

}


# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_algobase.c" 1
# 32 "c:/marmalade/7.5/s3e/h/std/c++/stl/_algobase.c"
namespace _STL {

template <class _InputIter1, class _InputIter2>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2) {
 
   
    for ( ; __first1 != __last1 && __first2 != __last2
     ; ++__first1, ++__first2) {
      if (*__first1 < *__first2)
 return true;
      if (*__first2 < *__first1)
 return false;
    }
  return __first1 == __last1 && __first2 != __last2;
}

template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _Compare __comp) {
 
   
    for ( ; __first1 != __last1 && __first2 != __last2
     ; ++__first1, ++__first2) {
      if (__comp(*__first1, *__first2))
 return true;
      if (__comp(*__first2, *__first1))
 return false;
    }
  return __first1 == __last1 && __first2 != __last2;
}



template <class _InputIter1, class _InputIter2>
int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _InputIter2 __last2)
{
  while (__first1 != __last1 && __first2 != __last2) {
    if (*__first1 < *__first2)
      return -1;
    if (*__first2 < *__first1)
      return 1;
    ++__first1;
    ++__first2;
  }
  if (__first2 == __last2) {
    return !(__first1 == __last1);
  }
  else {
    return -1;
  }
}


template <class _InputIter1, class _InputIter2>
int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                 _InputIter2 __first2, _InputIter2 __last2)
{
 
   
    return __lexicographical_compare_3way(__first1, __last1, __first2, __last2);
}


template <class _RandomAccessIter, class _Tp>
inline _RandomAccessIter __find(_RandomAccessIter __first, _RandomAccessIter __last,
                                           const _Tp& __val,
                                           const random_access_iterator_tag &)
{
  typename iterator_traits<_RandomAccessIter>::difference_type __trip_count = (__last - __first) >> 2;

  for ( ; __trip_count > 0 ; --__trip_count) {
    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;
  }

  switch(__last - __first) {
  case 3:
    if (*__first == __val) return __first;
    ++__first;
  case 2:
    if (*__first == __val) return __first;
    ++__first;
  case 1:
    if (*__first == __val) return __first;
    ++__first;
  case 0:
  default:
    return __last;
  }
}

template <class _RandomAccessIter, class _Predicate>
inline _RandomAccessIter __find_if(_RandomAccessIter __first, _RandomAccessIter __last,
                                              _Predicate __pred,
                                              const random_access_iterator_tag &)
{
  typename iterator_traits<_RandomAccessIter>::difference_type __trip_count = (__last - __first) >> 2;

  for ( ; __trip_count > 0 ; --__trip_count) {
    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;
  }

  switch(__last - __first) {
  case 3:
    if (__pred(*__first)) return __first;
    ++__first;
  case 2:
    if (__pred(*__first)) return __first;
    ++__first;
  case 1:
    if (__pred(*__first)) return __first;

  case 0:
  default:
    return __last;
  }
}

template <class _InputIter, class _Tp>
inline _InputIter __find(_InputIter __first, _InputIter __last,
    const _Tp& __val,
    const input_iterator_tag &)
{
  while (__first != __last && !(*__first == __val))
    ++__first;
  return __first;
}

template <class _InputIter, class _Predicate>
inline _InputIter __find_if(_InputIter __first, _InputIter __last,
                            _Predicate __pred,
                            const input_iterator_tag &)
{
  while (__first != __last && !__pred(*__first))
    ++__first;
  return __first;
}

template <class _InputIter, class _Predicate>
_InputIter find_if(_InputIter __first, _InputIter __last,
                   _Predicate __pred) {
 
    return __find_if(__first, __last, __pred, typename iterator_traits< _InputIter >::iterator_category());
}

template <class _InputIter, class _Tp>
_InputIter find(_InputIter __first, _InputIter __last, const _Tp& __val)
{
 
    return __find(__first, __last, __val, typename iterator_traits< _InputIter >::iterator_category());
}

template <class _ForwardIter1, class _ForwardIter2, class _BinaryPred>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2,
                     _BinaryPred __predicate)
{
 
   

    if (__first1 == __last1 || __first2 == __last2)
      return __first1;


  _ForwardIter2 __tmp(__first2);
  ++__tmp;
  if (__tmp == __last2) {
    while (__first1 != __last1 && !__predicate(*__first1, *__first2))
      ++__first1;
    return __first1;
  }



  _ForwardIter2 __p1, __p;

  __p1 = __first2; ++__p1;



  while (__first1 != __last1) {
    while (__first1 != __last1) {
      if (__predicate(*__first1, *__first2))
        break;
      ++__first1;
    }
    while (__first1 != __last1 && !__predicate(*__first1, *__first2))
      ++__first1;
    if (__first1 == __last1)
      return __last1;

    __p = __p1;
    _ForwardIter1 __current = __first1;
    if (++__current == __last1) return __last1;

    while (__predicate(*__current, *__p)) {
      if (++__p == __last2)
        return __first1;
      if (++__current == __last1)
        return __last1;
    }

    ++__first1;
  }
  return __first1;
}



template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
_InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
                           _ForwardIter __first2, _ForwardIter __last2,
                           _BinaryPredicate __comp) {
  for ( ; __first1 != __last1; ++__first1)
    for (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)
      if (__comp(*__first1, *__iter))
        return __first1;
  return __last1;
}
# 282 "c:/marmalade/7.5/s3e/h/std/c++/stl/_algobase.c"
template <class _ForwardIter1, class _ForwardIter2,
  class _BinaryPredicate>
_ForwardIter1 __find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
                         _ForwardIter2 __first2, _ForwardIter2 __last2,
                         const forward_iterator_tag &, const forward_iterator_tag &,
                         _BinaryPredicate __comp)
{
  if (__first2 == __last2)
    return __last1;
  else {
    _ForwardIter1 __result = __last1;
    while (1) {
      _ForwardIter1 __new_result
        = search(__first1, __last1, __first2, __last2, __comp);
      if (__new_result == __last1)
        return __result;
      else {
        __result = __new_result;
        __first1 = __new_result;
        ++__first1;
      }
    }
  }
}





}
# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_iterator.h" 1
# 37 "c:/marmalade/7.5/s3e/h/std/c++/stl/_iterator.h"
namespace _STL {
# 46 "c:/marmalade/7.5/s3e/h/std/c++/stl/_iterator.h"
template <class _Iterator>
class reverse_iterator :
  public iterator<typename iterator_traits<_Iterator>::iterator_category,
                  typename iterator_traits<_Iterator>::value_type,
                  typename iterator_traits<_Iterator>::difference_type,
                  typename iterator_traits<_Iterator>::pointer,
                  typename iterator_traits<_Iterator>::reference>
{
protected:
  _Iterator current;
  typedef reverse_iterator<_Iterator> _Self;
public:
  typedef typename iterator_traits<_Iterator>::iterator_category iterator_category;
  typedef typename iterator_traits<_Iterator>::value_type value_type;
  typedef typename iterator_traits<_Iterator>::difference_type difference_type;
  typedef typename iterator_traits<_Iterator>::pointer pointer;
  typedef typename iterator_traits<_Iterator>::reference reference;
  typedef _Iterator iterator_type;
public:
  reverse_iterator() {}
  explicit reverse_iterator(iterator_type __x) : current(__x) {}
  reverse_iterator(const _Self& __x) : current(__x.current) {}
  _Self& operator = (const _Self& __x) { current = __x.base(); return *this; }

  template <class _Iter>
  reverse_iterator(const reverse_iterator<_Iter>& __x) : current(__x.base()) {}
  template <class _Iter>
  _Self& operator = (const reverse_iterator<_Iter>& __x) { current = __x.base(); return *this; }


  iterator_type base() const { return current; }
  reference operator*() const {
    _Iterator __tmp = current;
    return *--__tmp;
  }
  pointer operator->() const { return &(operator*()); }
  _Self& operator++() {
    --current;
    return *this;
  }
  _Self operator++(int) {
    _Self __tmp = *this;
    --current;
    return __tmp;
  }
  _Self& operator--() {
    ++current;
    return *this;
  }
  _Self operator--(int) {
    _Self __tmp = *this;
    ++current;
    return __tmp;
  }

  _Self operator+(difference_type __n) const {
    return _Self(current - __n);
  }
  _Self& operator+=(difference_type __n) {
    current -= __n;
    return *this;
  }
  _Self operator-(difference_type __n) const {
    return _Self(current + __n);
  }
  _Self& operator-=(difference_type __n) {
    current += __n;
    return *this;
  }
  reference operator[](difference_type __n) const { return *(*this + __n); }
};

template <class _Iterator>
inline bool operator==(const reverse_iterator<_Iterator>& __x,
                       const reverse_iterator<_Iterator>& __y) {
  return __x.base() == __y.base();
}

template <class _Iterator>
inline bool operator<(const reverse_iterator<_Iterator>& __x,
                      const reverse_iterator<_Iterator>& __y) {
  return __y.base() < __x.base();
}



template <class _Iterator>
inline bool operator!=(const reverse_iterator<_Iterator>& __x,
                       const reverse_iterator<_Iterator>& __y) {
  return !(__x == __y);
}

template <class _Iterator>
inline bool operator>(const reverse_iterator<_Iterator>& __x,
                      const reverse_iterator<_Iterator>& __y) {
  return __y < __x;
}

template <class _Iterator>
inline bool operator<=(const reverse_iterator<_Iterator>& __x,
                       const reverse_iterator<_Iterator>& __y) {
  return !(__y < __x);
}

template <class _Iterator>
inline bool operator>=(const reverse_iterator<_Iterator>& __x,
                      const reverse_iterator<_Iterator>& __y) {
  return !(__x < __y);
}



template <class _Iterator>



inline typename reverse_iterator<_Iterator>::difference_type

operator-(const reverse_iterator<_Iterator>& __x,
          const reverse_iterator<_Iterator>& __y) {
  return __y.base() - __x.base();
}

template <class _Iterator, class _DifferenceType>
inline reverse_iterator<_Iterator>
operator+(_DifferenceType n,const reverse_iterator<_Iterator>& x) {
  return x.operator+(n);
}



template <class _Container>
class back_insert_iterator
  : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
  _Container* container;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;

  explicit back_insert_iterator(_Container& __x) : container(&__x) {}
  back_insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __val) {
    container->push_back(__val);
    return *this;
  }
  back_insert_iterator<_Container>& operator*() { return *this; }
  back_insert_iterator<_Container>& operator++() { return *this; }
  back_insert_iterator<_Container> operator++(int) { return *this; }
};

template <class _Container>
inline back_insert_iterator<_Container> back_inserter(_Container& __x) {
  return back_insert_iterator<_Container>(__x);
}

template <class _Container>
class front_insert_iterator
  : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
  _Container* container;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;
  explicit front_insert_iterator(_Container& __x) : container(&__x) {}
  front_insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __val) {
    container->push_front(__val);
    return *this;
  }
  front_insert_iterator<_Container>& operator*() { return *this; }
  front_insert_iterator<_Container>& operator++() { return *this; }
  front_insert_iterator<_Container>& operator++(int) { return *this; }
};

template <class _Container>
inline front_insert_iterator<_Container> front_inserter(_Container& __x) {
  return front_insert_iterator<_Container>(__x);
}

template <class _Container>
class insert_iterator
  : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
  _Container* container;
  typename _Container::iterator iter;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;
  insert_iterator(_Container& __x, typename _Container::iterator __i)
    : container(&__x), iter(__i) {}
  insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __val) {
    iter = container->insert(iter, __val);
    ++iter;
    return *this;
  }
  insert_iterator<_Container>& operator*() { return *this; }
  insert_iterator<_Container>& operator++() { return *this; }
  insert_iterator<_Container>& operator++(int) { return *this; }
};

template <class _Container, class _Iterator>
inline insert_iterator<_Container>
inserter(_Container& __x, _Iterator __i)
{
  typedef typename _Container::iterator __iter;
  return insert_iterator<_Container>(__x, __iter(__i));
}

}
# 313 "c:/marmalade/7.5/s3e/h/std/c++/stl/_algobase.c" 2
namespace _STL {


template <class _BidirectionalIter1, class _BidirectionalIter2,
  class _BinaryPredicate>
_BidirectionalIter1
__find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
           _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
           const bidirectional_iterator_tag &, const bidirectional_iterator_tag &,
           _BinaryPredicate __comp)
{
  typedef reverse_iterator<_BidirectionalIter1> _RevIter1;
  typedef reverse_iterator<_BidirectionalIter2> _RevIter2;

  _RevIter1 __rlast1(__first1);
  _RevIter2 __rlast2(__first2);
  _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,
                               _RevIter2(__last2), __rlast2,
                               __comp);

  if (__rresult == __rlast1)
    return __last1;
  else {
    _BidirectionalIter1 __result = __rresult.base();
    advance(__result, -distance(__first2, __last2));
    return __result;
  }
}


template <class _ForwardIter1, class _ForwardIter2,
  class _BinaryPredicate>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2,
         _BinaryPredicate __comp)
{
 
   
    return __find_end(__first1, __last1, __first2, __last2,

        typename iterator_traits< _ForwardIter1 >::iterator_category(),
        typename iterator_traits< _ForwardIter2 >::iterator_category(),




        __comp);
}

template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
_ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last,
      const _Tp& __val, const _Compare& __comp, _Distance*)
{
  _Distance __len = distance(__first, __last);
  _Distance __half;
  _ForwardIter __middle;

  while (__len > 0) {
    __half = __len >> 1;
    __middle = __first;
    advance(__middle, __half);
    if (__comp(*__middle, __val)) {
      __first = __middle;
      ++__first;
      __len = __len - __half - 1;
    }
    else
      __len = __half;
  }
  return __first;
}

}
# 576 "c:/marmalade/7.5/s3e/h/std/c++/stl/_algobase.h" 2
# 35 "c:/marmalade/7.5/s3e/h/std/c++/stl/_list.h" 2



# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_alloc.h" 1
# 48 "c:/marmalade/7.5/s3e/h/std/c++/stl/_alloc.h"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/cstdio" 1
# 35 "c:/marmalade/7.5/s3e/h/std/c++/cstdio"
# 1 "c:/marmalade/7.5/s3e/h/ext/../std/stdio.h" 1
# 19 "c:/marmalade/7.5/s3e/h/ext/../std/stdio.h"
struct __XXFILE;
typedef struct __XXFILE FILE;

typedef uint32 fpos_t;
# 38 "c:/marmalade/7.5/s3e/h/ext/../std/stdio.h"
extern "C" {



struct _reent
{
  int _errno;
  void *_stdin, *_stdout, *_stderr;
};
extern struct _reent *_impure_ptr;
# 73 "c:/marmalade/7.5/s3e/h/ext/../std/stdio.h"
FILE *fopen(const char *path, const char *mode);
int fclose(FILE *fp);
int fcloseall();
int fflush(FILE *stream);

FILE *fopen(const char *path, const char *mode);
FILE *fdopen(int fildes, const char *mode);
FILE *freopen(const char *path, const char *mode, FILE *stream);

size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);

int fputc(int c, FILE *stream);
int fputs(const char *s, FILE *stream);
int putc(int c, FILE *stream);
int putchar(int c);
int puts(const char *s);

int fgetc(FILE *stream);
char *fgets(char *s, int size, FILE *stream);
int getc(FILE *stream);
int getchar(void);
char *gets(char *s);
int ungetc(int c, FILE *stream);

int fseek(FILE *stream, long offset, int whence);
long ftell(FILE *stream);
void rewind(FILE *stream);
int fgetpos(FILE *stream, fpos_t *pos);
int fsetpos(FILE *stream, fpos_t *pos);

void flockfile(FILE *filehandle);
int ftrylockfile(FILE *filehandle);
void funlockfile(FILE *filehandle);

int getc_unlocked(FILE *stream);
int getchar_unlocked(void);
int putc_unlocked(int c, FILE *stream);
int putchar_unlocked(int c);

FILE *popen(const char *command, const char *type);
int pclose(FILE *stream);

char *tempnam(const char *dir, const char *pfx);




int printf(const char *format, ...) __attribute__((format(printf, 1, 2)));



int fprintf(FILE *stream, const char* format, ...) __attribute__((format(printf, 2, 3)));



int sprintf(char *str, const char* format, ...) __attribute__((format(printf, 2, 3)));



int snprintf(char *str, size_t size, const char *format, ...) __attribute__((format(printf, 3, 4)));




int scanf(const char *format, ...);



int fscanf(FILE *stream, const char *format, ...);



int sscanf(const char *str, const char *format, ...);

void clearerr(FILE *stream);
int feof(FILE *stream);
int ferror(FILE *stream);
int fileno(FILE *stream);

int remove(const char *pathname);
int rename(const char *oldpath, const char *newpath);

void perror(const char *s);



FILE *tmpfile(void);
char *tmpnam(char *s);

void setbuf(FILE *stream, char *buf);
void setbuffer(FILE *stream, char *buf, size_t size);
void setlinebuf(FILE *stream);
int setvbuf(FILE *stream, char *buf, int mode , size_t size);

# 1 "c:/marmalade/7.5/s3e/h/std/stdarg.h" 1
# 55 "c:/marmalade/7.5/s3e/h/std/stdarg.h"
typedef __builtin_va_list va_list;
# 169 "c:/marmalade/7.5/s3e/h/ext/../std/stdio.h" 2

int vfprintf(FILE *stream, const char *format, va_list ap);
int vsprintf(char *str, const char *format, va_list ap);
int vsnprintf(char *str, size_t size, const char *format, va_list ap);
int vprintf(const char *format, va_list ap);
int asprintf(char **strp, const char *fmt, ...);
int vasprintf(char **strp, const char *fmt, va_list ap);

int vscanf(const char *format, va_list ap);
int vsscanf(const char *str, const char *format, va_list ap);
int vfscanf(FILE *stream, const char *format, va_list ap);

}
# 36 "c:/marmalade/7.5/s3e/h/std/c++/cstdio" 2
# 58 "c:/marmalade/7.5/s3e/h/std/c++/cstdio"
namespace _STL {
using ::FILE;
using ::fpos_t;
using ::size_t;
# 72 "c:/marmalade/7.5/s3e/h/std/c++/cstdio"
using ::clearerr;
using ::fclose;
using ::feof;
using ::ferror;
using ::fflush;
using ::fgetc;
using ::fgetpos;
using ::fgets;
using ::fopen;
using ::fprintf;
using ::fputc;
using ::fputs;
using ::fread;
using ::freopen;
using ::fscanf;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::fwrite;


 using ::getc;
 using ::getchar;
 using ::putc;
 using ::putchar;


using ::gets;
using ::perror;
using ::printf;
using ::puts;
using ::remove;
using ::rename;
using ::rewind;
using ::scanf;
using ::setbuf;
using ::setvbuf;
using ::sprintf;
using ::sscanf;
using ::tmpfile;
using ::tmpnam;
using ::ungetc;
using ::vfprintf;
using ::vprintf;
using ::vsprintf;





}
# 49 "c:/marmalade/7.5/s3e/h/std/c++/stl/_alloc.h" 2
# 60 "c:/marmalade/7.5/s3e/h/std/c++/stl/_alloc.h"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_new.h" 1
# 11 "c:/marmalade/7.5/s3e/h/std/c++/stl/_new.h"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/exception" 1
# 58 "c:/marmalade/7.5/s3e/h/std/c++/exception"
# 1 "c:/marmalade/7.5/s3e/h/ext/../std/c++/exception.h" 1
# 18 "c:/marmalade/7.5/s3e/h/ext/../std/c++/exception.h"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/exception_gcc" 1
# 44 "c:/marmalade/7.5/s3e/h/std/c++/exception_gcc"
extern "C++" {

namespace std
{
# 56 "c:/marmalade/7.5/s3e/h/std/c++/exception_gcc"
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();


    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }


    virtual ~bad_exception() throw();
  };


  typedef void (*terminate_handler) ();

  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();


  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();


  void unexpected() __attribute__ ((__noreturn__));
# 104 "c:/marmalade/7.5/s3e/h/std/c++/exception_gcc"
  bool uncaught_exception() throw();
}

namespace __gnu_cxx
{
# 119 "c:/marmalade/7.5/s3e/h/std/c++/exception_gcc"
  void __verbose_terminate_handler ();
}

}
# 19 "c:/marmalade/7.5/s3e/h/ext/../std/c++/exception.h" 2
# 59 "c:/marmalade/7.5/s3e/h/std/c++/exception" 2
# 75 "c:/marmalade/7.5/s3e/h/std/c++/exception"
namespace _STL {


using __std_alias::exception;
using __std_alias::bad_exception;
# 106 "c:/marmalade/7.5/s3e/h/std/c++/exception"
}
# 12 "c:/marmalade/7.5/s3e/h/std/c++/stl/_new.h" 2

namespace _STL {

struct nothrow_t {};


extern const nothrow_t nothrow;




class bad_alloc : public exception {
public:
  bad_alloc () throw() { }
  bad_alloc(const bad_alloc&) throw() { }
  bad_alloc& operator=(const bad_alloc&) throw() {return *this;}
  ~bad_alloc () throw() { }
  const char* what() const throw() { return "bad alloc"; }
};

}
# 50 "c:/marmalade/7.5/s3e/h/std/c++/stl/_new.h"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/new" 1
# 38 "c:/marmalade/7.5/s3e/h/std/c++/new"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/new.h" 1
# 52 "c:/marmalade/7.5/s3e/h/std/c++/new.h"
inline void* operator new(size_t, void* p) { return p;};
inline void* operator new[](size_t, void* p) { return p;};
inline void operator delete(void*, void*) {};
inline void operator delete[](void*, void*) {};
# 39 "c:/marmalade/7.5/s3e/h/std/c++/new" 2
# 51 "c:/marmalade/7.5/s3e/h/std/c++/stl/_new.h" 2
# 80 "c:/marmalade/7.5/s3e/h/std/c++/stl/_new.h"
namespace _STL {





inline void* __stl_new(size_t __n) { void* __y = ::operator new(__n);if (__y == 0){;}return __y; }
inline void __stl_delete(void* __p) { ::operator delete(__p); }

}
# 61 "c:/marmalade/7.5/s3e/h/std/c++/stl/_alloc.h" 2



# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_threads.h" 1
# 57 "c:/marmalade/7.5/s3e/h/std/c++/stl/_threads.h"
  typedef size_t __stl_atomic_t;
# 280 "c:/marmalade/7.5/s3e/h/std/c++/stl/_threads.h"
namespace _STL {




template <int __inst>
struct _STLP_mutex_spin {
  enum { __low_max = 30, __high_max = 1000 };

  static unsigned __max;
  static unsigned __last;
  static void _M_do_lock(volatile __stl_atomic_t* __lock);
  static void _S_nsec_sleep(int __log_nsec);
};
# 311 "c:/marmalade/7.5/s3e/h/std/c++/stl/_threads.h"
struct _STLP_mutex_base
{
# 441 "c:/marmalade/7.5/s3e/h/std/c++/stl/_threads.h"
  inline void _M_initialize() {}
  inline void _M_destroy() {}
  inline void _M_acquire_lock() {}
  inline void _M_release_lock() {}

};
# 458 "c:/marmalade/7.5/s3e/h/std/c++/stl/_threads.h"
typedef _STLP_mutex_base _STLP_mutex_nodemand;





class _STLP_mutex : public _STLP_mutex_nodemand {
  public:
    inline _STLP_mutex () { _M_initialize(); }
    inline ~_STLP_mutex () { _M_destroy(); }
  private:
    _STLP_mutex(const _STLP_mutex&);
    void operator=(const _STLP_mutex&);
};
# 569 "c:/marmalade/7.5/s3e/h/std/c++/stl/_threads.h"
struct _Refcount_Base
{

  volatile __stl_atomic_t _M_ref_count;


  _STLP_mutex _M_mutex;



  _Refcount_Base(__stl_atomic_t __n) : _M_ref_count(__n) {}
# 597 "c:/marmalade/7.5/s3e/h/std/c++/stl/_threads.h"
  void _M_incr() { ++_M_ref_count; }
  void _M_decr() { --_M_ref_count; }

};
# 632 "c:/marmalade/7.5/s3e/h/std/c++/stl/_threads.h"
static inline __stl_atomic_t
_Atomic_swap(volatile __stl_atomic_t * __p, __stl_atomic_t __q) {
  __stl_atomic_t __result = *__p;
  *__p = __q;
  return __result;
}






struct _STLP_auto_lock
{
  _STLP_mutex_base& _M_lock;

  _STLP_auto_lock(_STLP_mutex_base& __lock) : _M_lock(__lock)
    { _M_lock._M_acquire_lock(); }
  ~_STLP_auto_lock() { _M_lock._M_release_lock(); }

private:
  void operator=(const _STLP_auto_lock&);
  _STLP_auto_lock(const _STLP_auto_lock&);
};

typedef _STLP_auto_lock _STLP_mutex_lock;
# 710 "c:/marmalade/7.5/s3e/h/std/c++/stl/_threads.h"
}


# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_threads.c" 1
# 714 "c:/marmalade/7.5/s3e/h/std/c++/stl/_threads.h" 2
# 65 "c:/marmalade/7.5/s3e/h/std/c++/stl/_alloc.h" 2



# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_construct.h" 1
# 46 "c:/marmalade/7.5/s3e/h/std/c++/stl/_construct.h"
namespace _STL {
# 55 "c:/marmalade/7.5/s3e/h/std/c++/stl/_construct.h"
template <class _Tp>
inline void _Destroy(_Tp* __pointer) {
# 67 "c:/marmalade/7.5/s3e/h/std/c++/stl/_construct.h"
    __pointer->~_Tp();





}
# 92 "c:/marmalade/7.5/s3e/h/std/c++/stl/_construct.h"
template <class _T1, class _T2>
inline void _Construct(_T1* __p, const _T2& __val) {



    new (__p) _T1(__val);
}

template <class _T1>
inline void _Construct(_T1* __p) {







  new (__p) _T1();

}
# 120 "c:/marmalade/7.5/s3e/h/std/c++/stl/_construct.h"
template <class _ForwardIterator>
inline void
__destroy_aux(_ForwardIterator __first, _ForwardIterator __last, const __false_type&) {
  for ( ; __first != __last; ++__first)
    _STL::_Destroy(&*__first);
}

template <class _ForwardIterator>
inline void __destroy_aux(_ForwardIterator, _ForwardIterator, const __true_type&) {}

template <class _ForwardIterator, class _Tp>
inline void
__destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*) {
  typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
  __destroy_aux(__first, __last, _Trivial_destructor());
}

template <class _ForwardIterator>
inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last) {
  __destroy(__first, __last, (typename iterator_traits< _ForwardIterator >::value_type*)0);
}

inline void _Destroy(char*, char*) {}

inline void _Destroy(wchar_t*, wchar_t*) {}
inline void _Destroy(const wchar_t*, const wchar_t*) {}






template <class _T1, class _T2>
inline void construct(_T1* __p, const _T2& __val) {_Construct(__p, __val); }
template <class _T1>
inline void construct(_T1* __p) { _Construct(__p); }
template <class _Tp>
inline void destroy(_Tp* __pointer) { _STL::_Destroy(__pointer); }
template <class _ForwardIterator>
inline void destroy(_ForwardIterator __first, _ForwardIterator __last) { _STL::_Destroy(__first, __last); }

}
# 69 "c:/marmalade/7.5/s3e/h/std/c++/stl/_alloc.h" 2
# 85 "c:/marmalade/7.5/s3e/h/std/c++/stl/_alloc.h"
namespace _STL {
# 94 "c:/marmalade/7.5/s3e/h/std/c++/stl/_alloc.h"
typedef void (* __oom_handler_type)();

template <int __inst>
class __malloc_alloc {
private:
  static void* _S_oom_malloc(size_t);
  static __oom_handler_type __oom_handler;
public:

  typedef char value_type;





  static void* allocate(size_t __n) {
    void* __result = malloc(__n);
    if (0 == __result) __result = _S_oom_malloc(__n);
    return __result;
  }
  static void deallocate(void* __p, size_t ) { free((char*)__p); }
  static __oom_handler_type set_malloc_handler(__oom_handler_type __f) {
    __oom_handler_type __old = __oom_handler;
    __oom_handler = __f;
    return(__old);
  }
};




class __new_alloc {
public:

  typedef char value_type;





  static void* allocate(size_t __n) { return __stl_new(__n); }
  static void deallocate(void* __p, size_t) { __stl_delete(__p); }
};
# 146 "c:/marmalade/7.5/s3e/h/std/c++/stl/_alloc.h"
template <class _Alloc>
class __debug_alloc : public _Alloc {
public:
  typedef _Alloc __allocator_type;
  typedef typename _Alloc::value_type value_type;
private:
  struct __alloc_header {
    size_t __magic: 16;
    size_t __type_size:16;
    unsigned long _M_size;
  };

  enum { __pad=8, __magic=0xdeba, __deleted_magic = 0xdebd,
  __shred_byte= 0xA3
  };

  enum { __extra_before = 16, __extra_after = 8 };



  static size_t __extra_before_chunk() {
    return (long)__extra_before/sizeof(value_type)+
      (size_t)((long)__extra_before%sizeof(value_type)>0);
  }
  static size_t __extra_after_chunk() {
    return (long)__extra_after/sizeof(value_type)+
      (size_t)((long)__extra_after%sizeof(value_type)>0);
  }
public:





  __debug_alloc() {}
  ~__debug_alloc() {}
  static void * allocate(size_t);
  static void deallocate(void *, size_t);
};
# 214 "c:/marmalade/7.5/s3e/h/std/c++/stl/_alloc.h"
enum {_ALIGN = 8, _ALIGN_SHIFT=3, _MAX_BYTES = 128};



class _Node_alloc_obj {
public:
    _Node_alloc_obj * _M_free_list_link;
};

template <bool __threads, int __inst>
class __node_alloc {
  public:
  static inline size_t _S_round_up(size_t __bytes) { return (((__bytes) + (size_t)_ALIGN-1) & ~((size_t)_ALIGN - 1)); }
  typedef _Node_alloc_obj _Obj;
private:

  static void* _S_refill(size_t __n);


  static char* _S_chunk_alloc(size_t __p_size, int& __nobjs);

  static _Node_alloc_obj * _S_free_list[16];
  static char* _S_start_free;
  static char* _S_end_free;
  static size_t _S_heap_size;
  static void * _M_allocate(size_t __n);

  static void _M_deallocate(void *__p, size_t __n);
public:

  typedef char value_type;






  static void * allocate(size_t __n) { return (__n > (size_t)_MAX_BYTES) ? __stl_new(__n) : _M_allocate(__n); }

  static void deallocate(void *__p, size_t __n) { if (__n > (size_t)_MAX_BYTES) __stl_delete(__p); else _M_deallocate(__p, __n); }
};





typedef __node_alloc<false, 0> _Node_alloc;
# 301 "c:/marmalade/7.5/s3e/h/std/c++/stl/_alloc.h"
typedef __malloc_alloc<0> __sgi_alloc;


typedef __malloc_alloc<0> __single_client_alloc;
typedef __malloc_alloc<0> __multithreaded_alloc;
# 329 "c:/marmalade/7.5/s3e/h/std/c++/stl/_alloc.h"
template <class _Tp>
class allocator {
public:

  typedef _Tp value_type;
  typedef value_type * pointer;
  typedef const _Tp* const_pointer;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() {}

  template <class _Tp1> allocator(const allocator<_Tp1>&) {}

  allocator(const allocator<_Tp>&) {}
  ~allocator() {}
  pointer address(reference __x) const { return &__x; }
  const_pointer address(const_reference __x) const { return &__x; }

  _Tp* allocate(size_type __n, const void* = 0) {
    return __n != 0 ? reinterpret_cast<value_type*>(__sgi_alloc::allocate(__n * sizeof(value_type))) : 0;
  }

  void deallocate(pointer __p, size_type __n) {
   
      if (__p != 0) __sgi_alloc::deallocate((void*)__p, __n * sizeof(value_type));
  }

  void deallocate(pointer __p) const { if (__p != 0) __sgi_alloc::deallocate((void*)__p, sizeof(value_type)); }
  size_type max_size() const { return size_t(-1) / sizeof(value_type); }
  void construct(pointer __p, const _Tp& __val) { _STL::_Construct(__p, __val); }
  void destroy(pointer __p) { _STL::_Destroy(__p); }




};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;

  typedef void value_type;


  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };





};


template <class _T1, class _T2> inline bool operator==(const allocator<_T1>&, const allocator<_T2>&) { return true; }
template <class _T1, class _T2> inline bool operator!=(const allocator<_T1>&, const allocator<_T2>&) { return false; }
# 411 "c:/marmalade/7.5/s3e/h/std/c++/stl/_alloc.h"
template <class _Tp, class _Allocator>
struct _Alloc_traits
{
  typedef _Allocator _Orig;

  typedef typename _Allocator::template rebind<_Tp> _Rebind_type;
  typedef typename _Rebind_type::other allocator_type;
  static allocator_type create_allocator(const _Orig& __a) { return allocator_type(__a); }





};
# 457 "c:/marmalade/7.5/s3e/h/std/c++/stl/_alloc.h"
template <class _Tp, class _Alloc>
inline typename _Alloc_traits<_Tp, _Alloc>::allocator_type
__stl_alloc_create(const _Alloc& __a, const _Tp*) {
  typedef typename _Alloc::template rebind<_Tp>::other _Rebound_type;
  return _Rebound_type(__a);
}
# 480 "c:/marmalade/7.5/s3e/h/std/c++/stl/_alloc.h"
template <class _Value, class _Tp, class _MaybeReboundAlloc>
class _STLP_alloc_proxy : public _MaybeReboundAlloc {
private:
  typedef _MaybeReboundAlloc _Base;
  typedef _STLP_alloc_proxy<_Value, _Tp, _MaybeReboundAlloc> _Self;
public:
  _Value _M_data;
  inline _STLP_alloc_proxy(const _MaybeReboundAlloc& __a, _Value __p) : _MaybeReboundAlloc(__a), _M_data(__p) {}
# 509 "c:/marmalade/7.5/s3e/h/std/c++/stl/_alloc.h"
};
# 520 "c:/marmalade/7.5/s3e/h/std/c++/stl/_alloc.h"
}
# 39 "c:/marmalade/7.5/s3e/h/std/c++/stl/_list.h" 2
# 50 "c:/marmalade/7.5/s3e/h/std/c++/stl/_list.h"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_function_base.h" 1
# 37 "c:/marmalade/7.5/s3e/h/std/c++/stl/_function_base.h"
namespace _STL {

template <class _Arg, class _Result>
struct unary_function {
  typedef _Arg argument_type;
  typedef _Result result_type;
};

template <class _Arg1, class _Arg2, class _Result>
struct binary_function {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;
};

template <class _Tp>
struct equal_to : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x == __y; }
};

template <class _Tp>
struct not_equal_to : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x != __y; }
};

template <class _Tp>
struct greater : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x > __y; }
};

template <class _Tp>
struct less : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x < __y; }
};

template <class _Tp>
struct greater_equal : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x >= __y; }
};

template <class _Tp>
struct less_equal : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x <= __y; }
};

template <class _Tp>
less<_Tp> __less(_Tp* ) { return less<_Tp>(); }

template <class _Tp>
equal_to<_Tp> __equal_to(_Tp* ) { return equal_to<_Tp>(); }

template <class _Tp>
struct plus : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x + __y; }
};

template <class _Tp>
struct minus : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x - __y; }
};

template <class _Tp>
plus<_Tp> __plus(_Tp* ) { return plus<_Tp>(); }

template <class _Tp>
minus<_Tp> __minus(_Tp* ) { return minus<_Tp>(); }

template <class _Tp>
struct multiplies : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x * __y; }
};

template <class _Tp>
struct divides : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x / __y; }
};

template <class _Tp>
struct modulus : public binary_function<_Tp,_Tp,_Tp>
{
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x % __y; }
};

template <class _Tp>
struct negate : public unary_function<_Tp,_Tp>
{
  _Tp operator()(const _Tp& __x) const { return -__x; }
};

template <class _Tp>
struct logical_and : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x && __y; }
};

template <class _Tp>
struct logical_or : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x || __y; }
};

template <class _Tp>
struct logical_not : public unary_function<_Tp,bool>
{
  bool operator()(const _Tp& __x) const { return !__x; }
};

template <class _Pair>
struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {
  const typename _Pair::first_type& operator()(const _Pair& __x) const {
    return __x.first;
  }
};

template <class _Pair>
struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type>
{
  const typename _Pair::second_type& operator()(const _Pair& __x) const {
    return __x.second;
  }
};


template <class _Arg1, class _Arg2>
struct _Project1st : public binary_function<_Arg1, _Arg2, _Arg1> {
  _Arg1 operator()(const _Arg1& __x, const _Arg2&) const { return __x; }
};

template <class _Arg1, class _Arg2>
struct _Project2nd : public binary_function<_Arg1, _Arg2, _Arg2> {
  _Arg2 operator()(const _Arg1&, const _Arg2& __y) const { return __y; }
};
# 188 "c:/marmalade/7.5/s3e/h/std/c++/stl/_function_base.h"
template <class _Tp>
struct _Identity : public unary_function<_Tp,_Tp> {
  const _Tp& operator()(const _Tp& __x) const { return __x; }
};

template <class _Result, class _Argument>
struct _Constant_unary_fun {
  typedef _Argument argument_type;
  typedef _Result result_type;
  result_type _M_val;

  _Constant_unary_fun(const result_type& __v) : _M_val(__v) {}
  const result_type& operator()(const _Argument&) const { return _M_val; }
};

template <class _Result, class _Arg1, class _Arg2>
struct _Constant_binary_fun {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;
  _Result _M_val;

  _Constant_binary_fun(const _Result& __v) : _M_val(__v) {}
  const result_type& operator()(const _Arg1&, const _Arg2&) const {
    return _M_val;
  }
};


template <class _Tp> inline _Tp __identity_element(plus<_Tp>) { return _Tp(0); }
template <class _Tp> inline _Tp __identity_element(multiplies<_Tp>) { return _Tp(1); }

}
# 51 "c:/marmalade/7.5/s3e/h/std/c++/stl/_list.h" 2


namespace _STL {




struct _List_node_base {
  _List_node_base* _M_next;
  _List_node_base* _M_prev;
};

template <class _Dummy>
class _List_global {
public:
  typedef _List_node_base _Node;
  static void _Transfer(_List_node_base* __position,
                                    _List_node_base* __first, _List_node_base* __last);
};




typedef _List_global<bool> _List_global_inst;

template <class _Tp>
struct _List_node : public _List_node_base {
  _Tp _M_data;
 






};

struct _List_iterator_base {
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef bidirectional_iterator_tag iterator_category;

  _List_node_base* _M_node;

  _List_iterator_base(_List_node_base* __x) : _M_node(__x) {}
  _List_iterator_base() {}

  void _M_incr() { _M_node = _M_node->_M_next; }
  void _M_decr() { _M_node = _M_node->_M_prev; }
  bool operator==(const _List_iterator_base& __y ) const {
    return _M_node == __y._M_node;
  }
  bool operator!=(const _List_iterator_base& __y ) const {
    return _M_node != __y._M_node;
  }
};




template<class _Tp, class _Traits>
struct _List_iterator : public _List_iterator_base {
  typedef _Tp value_type;
  typedef typename _Traits::pointer pointer;
  typedef typename _Traits::reference reference;

  typedef _List_iterator<_Tp, _Nonconst_traits<_Tp> > iterator;
  typedef _List_iterator<_Tp, _Const_traits<_Tp> > const_iterator;
  typedef _List_iterator<_Tp, _Traits> _Self;

  typedef bidirectional_iterator_tag iterator_category;
  typedef _List_node<_Tp> _Node;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  _List_iterator(_Node* __x) : _List_iterator_base(__x) {}
  _List_iterator() {}
  _List_iterator(const iterator& __x) : _List_iterator_base(__x._M_node) {}

  reference operator*() const { return ((_Node*)_M_node)->_M_data; }

  pointer operator->() const { return &(operator*()); }

  _Self& operator++() {
    this->_M_incr();
    return *this;
  }
  _Self operator++(int) {
    _Self __tmp = *this;
    this->_M_incr();
    return __tmp;
  }
  _Self& operator--() {
    this->_M_decr();
    return *this;
  }
  _Self operator--(int) {
    _Self __tmp = *this;
    this->_M_decr();
    return __tmp;
  }
};
# 166 "c:/marmalade/7.5/s3e/h/std/c++/stl/_list.h"
template <class _Tp, class _Alloc>
class _List_base
{
protected:
 
  typedef _List_node<_Tp> _Node;
  typedef typename _Alloc_traits<_Node, _Alloc>::allocator_type
           _Node_allocator_type;
public:
  typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type
          allocator_type;

  allocator_type get_allocator() const {
    return (const _Node_allocator_type&)_M_node;
  }

  _List_base(const allocator_type& __a) : _M_node(__a, (_Node*)0) {
    _Node* __n = _M_node.allocate(1);
    __n->_M_next = __n;
    __n->_M_prev = __n;
    _M_node._M_data = __n;
  }
  ~_List_base() {
    clear();
    _M_node.deallocate(_M_node._M_data, 1);
  }

  void clear();

public:
  _STLP_alloc_proxy<_Node*, _Node, _Node_allocator_type> _M_node;
};

template <class _Tp, class _Alloc = allocator< _Tp > >
class list;


template <class _Tp, class _Alloc, class _Predicate>
void _S_remove_if(list<_Tp, _Alloc>& __that, _Predicate __pred);

template <class _Tp, class _Alloc, class _BinaryPredicate>
void _S_unique(list<_Tp, _Alloc>& __that, _BinaryPredicate __binary_pred);

template <class _Tp, class _Alloc, class _StrictWeakOrdering>
void _S_merge(list<_Tp, _Alloc>& __that, list<_Tp, _Alloc>& __x,
       _StrictWeakOrdering __comp);

template <class _Tp, class _Alloc, class _StrictWeakOrdering>
void _S_sort(list<_Tp, _Alloc>& __that, _StrictWeakOrdering __comp);

template <class _Tp, class _Alloc>
class list : public _List_base<_Tp, _Alloc> {
  typedef _List_base<_Tp, _Alloc> _Base;
  typedef list<_Tp, _Alloc> _Self;
public:
  typedef _Tp value_type;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef _List_node<_Tp> _Node;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
 
  typedef typename _Base::allocator_type allocator_type;
  typedef bidirectional_iterator_tag _Iterator_category;

public:
  typedef _List_iterator<_Tp, _Nonconst_traits<_Tp> > iterator;
  typedef _List_iterator<_Tp, _Const_traits<_Tp> > const_iterator;
  typedef _STL::reverse_iterator<const_iterator> const_reverse_iterator; typedef _STL::reverse_iterator<iterator> reverse_iterator;

protected:
  _Node* _M_create_node(const _Tp& __x)
  {
    _Node* __p = this->_M_node.allocate(1);
    {
      _Construct(&__p->_M_data, __x);
    }
    ;
    return __p;
  }

  _Node* _M_create_node()
  {
    _Node* __p = this->_M_node.allocate(1);
    {
      _Construct(&__p->_M_data);
    }
    ;
    return __p;
  }

public:

  explicit

  list(const allocator_type& __a = allocator_type()) :
    _List_base<_Tp, _Alloc>(__a) {}

  iterator begin() { return iterator((_Node*)(this->_M_node._M_data->_M_next)); }
  const_iterator begin() const { return const_iterator((_Node*)(this->_M_node._M_data->_M_next)); }

  iterator end() { return this->_M_node._M_data; }
  const_iterator end() const { return this->_M_node._M_data; }

  reverse_iterator rbegin()
    { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const
    { return const_reverse_iterator(end()); }

  reverse_iterator rend()
    { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const
    { return const_reverse_iterator(begin()); }

  bool empty() const { return this->_M_node._M_data->_M_next == this->_M_node._M_data; }
  size_type size() const {
    size_type __result = distance(begin(), end());
    return __result;
  }
  size_type max_size() const { return size_type(-1); }

  reference front() { return *begin(); }
  const_reference front() const { return *begin(); }
  reference back() { return *(--end()); }
  const_reference back() const { return *(--end()); }

  void swap(list<_Tp, _Alloc>& __x) {
    _STL::swap(this->_M_node, __x._M_node);
  }

  iterator insert(iterator __position, const _Tp& __x) {

    _Node* __tmp = _M_create_node(__x);
    _List_node_base* __n = __position._M_node;
    _List_node_base* __p = __n->_M_prev;
    __tmp->_M_next = __n;
    __tmp->_M_prev = __p;
    __p->_M_next = __tmp;
    __n->_M_prev = __tmp;
    return __tmp;
  }


  template <class _InputIterator>
  void insert(iterator __pos, _InputIterator __first, _InputIterator __last) {
    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
    _M_insert_dispatch(__pos, __first, __last, _Integral());
  }

  template<class _Integer>
  void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
                          const __true_type&) {
    _M_fill_insert(__pos, (size_type) __n, (_Tp) __x);
  }
  template <class _InputIter>
  void
  _M_insert_dispatch(iterator __position,
       _InputIter __first, _InputIter __last,
       const __false_type&)







  {
    for ( ; __first != __last; ++__first)
      insert(__position, *__first);
  }
  void insert(iterator __pos, size_type __n, const _Tp& __x) { _M_fill_insert(__pos, __n, __x); }

  void _M_fill_insert(iterator __pos, size_type __n, const _Tp& __x) {
    for ( ; __n > 0; --__n)
      insert(__pos, __x);
  }
  void push_front(const _Tp& __x) { insert(begin(), __x); }
  void push_back(const _Tp& __x) { insert(end(), __x); }


  iterator insert(iterator __position) { return insert(__position, _Tp()); }
  void push_front() {insert(begin());}
  void push_back() {insert(end());}


  iterator erase(iterator __position) {
    _List_node_base* __next_node = __position._M_node->_M_next;
    _List_node_base* __prev_node = __position._M_node->_M_prev;
    _Node* __n = (_Node*) __position._M_node;
    __prev_node->_M_next = __next_node;
    __next_node->_M_prev = __prev_node;
    _STL::_Destroy(&__n->_M_data);
    this->_M_node.deallocate(__n, 1);
    return iterator((_Node*)__next_node);
    }

  iterator erase(iterator __first, iterator __last) {
    while (__first != __last)
      erase(__first++);
    return __last;
  }

  void resize(size_type __new_size, _Tp __x);
  void resize(size_type __new_size) { this->resize(__new_size, _Tp()); }

  void pop_front() { erase(begin()); }
  void pop_back() {
    iterator __tmp = end();
    erase(--__tmp);
  }
  list(size_type __n, const _Tp& __val,
       const allocator_type& __a = allocator_type())
    : _List_base<_Tp, _Alloc>(__a)
    { this->insert(begin(), __n, __val); }
  explicit list(size_type __n)
    : _List_base<_Tp, _Alloc>(allocator_type())
    { this->insert(begin(), __n, _Tp()); }
# 395 "c:/marmalade/7.5/s3e/h/std/c++/stl/_list.h"
  template <class _InputIterator>
  list(_InputIterator __first, _InputIterator __last,
       const allocator_type& __a = allocator_type())
    : _List_base<_Tp, _Alloc>(__a)
  { insert(begin(), __first, __last); }
# 413 "c:/marmalade/7.5/s3e/h/std/c++/stl/_list.h"
  list(const list<_Tp, _Alloc>& __x) : _List_base<_Tp, _Alloc>(__x.get_allocator())
    { insert(begin(), __x.begin(), __x.end()); }

  ~list() { }

  list<_Tp, _Alloc>& operator=(const list<_Tp, _Alloc>& __x);

public:





  void assign(size_type __n, const _Tp& __val) { _M_fill_assign(__n, __val); }

  void _M_fill_assign(size_type __n, const _Tp& __val);



  template <class _InputIterator>
  void assign(_InputIterator __first, _InputIterator __last) {
    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
    _M_assign_dispatch(__first, __last, _Integral());
  }

  template <class _Integer>
  void _M_assign_dispatch(_Integer __n, _Integer __val, const __true_type&)
    { assign((size_type) __n, (_Tp) __val); }

  template <class _InputIterator>
  void _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
                          const __false_type&) {
    iterator __first1 = begin();
    iterator __last1 = end();
    for ( ; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)
      *__first1 = *__first2;
    if (__first2 == __last2)
      erase(__first1, __last1);
    else
      insert(__last1, __first2, __last2);
  }



public:
  void splice(iterator __position, _Self& __x) {
    if (!__x.empty())
      _List_global_inst::_Transfer(__position._M_node, __x.begin()._M_node, __x.end()._M_node);
  }
  void splice(iterator __position, _Self&, iterator __i) {
    iterator __j = __i;
    ++__j;
    if (__position == __i || __position == __j) return;
    _List_global_inst::_Transfer(__position._M_node, __i._M_node, __j._M_node);
  }
  void splice(iterator __position, _Self&, iterator __first, iterator __last) {
    if (__first != __last)
      _List_global_inst::_Transfer(__position._M_node, __first._M_node, __last._M_node);
  }

  void remove(const _Tp& __val) {
    iterator __first = begin();
    iterator __last = end();
    while (__first != __last) {
      iterator __next = __first;
      ++__next;
      if (__val == *__first) erase(__first);
      __first = __next;
    }
  }

  void unique() {
    _S_unique(*this, equal_to<_Tp>());
  }

  void merge(_Self& __x) {
    _S_merge(*this, __x, less<_Tp>());
  }

  void reverse() {
    _List_node_base* __p = this->_M_node._M_data;
    _List_node_base* __tmp = __p;
    do {
      _STL::swap(__tmp->_M_next, __tmp->_M_prev);
      __tmp = __tmp->_M_prev;
    } while (__tmp != __p);
  }

  void sort() {
    _S_sort(*this, less<_Tp>());
  }


  template <class _Predicate> void remove_if(_Predicate __pred) {
    _S_remove_if(*this, __pred);
  }
  template <class _BinaryPredicate>
    void unique(_BinaryPredicate __binary_pred) {
    _S_unique(*this, __binary_pred);
  }

  template <class _StrictWeakOrdering>
    void merge(list<_Tp, _Alloc>& __x,
   _StrictWeakOrdering __comp) {
    _S_merge(*this, __x, __comp);
  }

  template <class _StrictWeakOrdering>
    void sort(_StrictWeakOrdering __comp) {
    _S_sort(*this, __comp);
  }


};

template <class _Tp, class _Alloc>
inline bool
operator==(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)
{
  typedef typename list<_Tp,_Alloc>::const_iterator const_iterator;
  const_iterator __end1 = __x.end();
  const_iterator __end2 = __y.end();

  const_iterator __i1 = __x.begin();
  const_iterator __i2 = __y.begin();
  while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2) {
    ++__i1;
    ++__i2;
  }
  return __i1 == __end1 && __i2 == __end2;
}




# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_relops_cont.h" 1
# 14 "c:/marmalade/7.5/s3e/h/std/c++/stl/_relops_cont.h"
template <class _Tp, class _Alloc>
inline bool operator<(const list<_Tp, _Alloc>& __x,
                                  const list<_Tp, _Alloc>& __y) {
  return lexicographical_compare(__x.begin(), __x.end(),
     __y.begin(), __y.end());
}

template <class _Tp, class _Alloc> inline bool operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y) {return !(__x == __y);}template <class _Tp, class _Alloc> inline bool operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y) {return __y < __x;}template <class _Tp, class _Alloc> inline bool operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y) { return !(__y < __x);}template <class _Tp, class _Alloc> inline bool operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y) { return !(__x < __y);}


template <class _Tp, class _Alloc>
inline void swap(list<_Tp, _Alloc>& __x,
                             list<_Tp, _Alloc>& __y) {
  __x.swap(__y);
}
# 549 "c:/marmalade/7.5/s3e/h/std/c++/stl/_list.h" 2




}


# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_list.c" 1
# 40 "c:/marmalade/7.5/s3e/h/std/c++/stl/_list.c"
namespace _STL {
# 65 "c:/marmalade/7.5/s3e/h/std/c++/stl/_list.c"
template <class _Tp, class _Alloc>
void
_List_base<_Tp,_Alloc>::clear()
{
  _List_node<_Tp>* __cur = (_List_node<_Tp>*) this->_M_node._M_data->_M_next;
  while (__cur != this->_M_node._M_data) {
    _List_node<_Tp>* __tmp = __cur;
    __cur = (_List_node<_Tp>*) __cur->_M_next;
    _STL::_Destroy(&__tmp->_M_data);
    this->_M_node.deallocate(__tmp, 1);
  }
  this->_M_node._M_data->_M_next = this->_M_node._M_data;
  this->_M_node._M_data->_M_prev = this->_M_node._M_data;
}





template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::resize(size_type __new_size, _Tp __x)
{
  iterator __i = begin();
  size_type __len = 0;
  for ( ; __i != end() && __len < __new_size; ++__i, ++__len);

  if (__len == __new_size)
    erase(__i, end());
  else
    insert(end(), __new_size - __len, __x);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>& list<_Tp, _Alloc>::operator=(const list<_Tp, _Alloc>& __x)
{
  if (this != &__x) {
    iterator __first1 = begin();
    iterator __last1 = end();
    const_iterator __first2 = __x.begin();
    const_iterator __last2 = __x.end();
    while (__first1 != __last1 && __first2 != __last2)
      *__first1++ = *__first2++;
    if (__first2 == __last2)
      erase(__first1, __last1);
    else
      insert(__last1, __first2, __last2);
  }
  return *this;
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::_M_fill_assign(size_type __n, const _Tp& __val) {
  iterator __i = begin();
  for ( ; __i != end() && __n > 0; ++__i, --__n)
    *__i = __val;
  if (__n > 0)
    insert(end(), __n, __val);
  else
    erase(__i, end());
}

template <class _Tp, class _Alloc, class _Predicate>
void _S_remove_if(list<_Tp, _Alloc>& __that, _Predicate __pred) {
  typename list<_Tp, _Alloc>::iterator __first = __that.begin();
  typename list<_Tp, _Alloc>::iterator __last = __that.end();
  while (__first != __last) {
    typename list<_Tp, _Alloc>::iterator __next = __first;
    ++__next;
    if (__pred(*__first)) __that.erase(__first);
    __first = __next;
  }
}

template <class _Tp, class _Alloc, class _BinaryPredicate>
void _S_unique(list<_Tp, _Alloc>& __that, _BinaryPredicate __binary_pred) {
  typename list<_Tp, _Alloc>::iterator __first = __that.begin();
  typename list<_Tp, _Alloc>::iterator __last = __that.end();
  if (__first == __last) return;
  typename list<_Tp, _Alloc>::iterator __next = __first;
  while (++__next != __last) {
    if (__binary_pred(*__first, *__next))
      __that.erase(__next);
    else
      __first = __next;
    __next = __first;
  }
}

template <class _Tp, class _Alloc, class _StrictWeakOrdering>
void _S_merge(list<_Tp, _Alloc>& __that, list<_Tp, _Alloc>& __x,
       _StrictWeakOrdering __comp) {
  typedef typename list<_Tp, _Alloc>::iterator _Literator;
  _Literator __first1 = __that.begin();
  _Literator __last1 = __that.end();
  _Literator __first2 = __x.begin();
  _Literator __last2 = __x.end();
  while (__first1 != __last1 && __first2 != __last2)
    if (__comp(*__first2, *__first1)) {
      _Literator __next = __first2;
      _List_global_inst::_Transfer(__first1._M_node, __first2._M_node, (++__next)._M_node);
      __first2 = __next;
    }
    else
      ++__first1;
  if (__first2 != __last2) _List_global_inst::_Transfer(__last1._M_node, __first2._M_node, __last2._M_node);
}

template <class _Tp, class _Alloc, class _StrictWeakOrdering>
void _S_sort(list<_Tp, _Alloc>& __that, _StrictWeakOrdering __comp) {

  if (__that._M_node._M_data->_M_next != __that._M_node._M_data &&
      (__that._M_node._M_data->_M_next)->_M_next != __that._M_node._M_data) {
    list<_Tp, _Alloc> __carry;

    list<_Tp, _Alloc> __counter[64];



    int __fill = 0;
    while (!__that.empty()) {
      __carry.splice(__carry.begin(), __that, __that.begin());
      int __i = 0;
      while(__i < __fill && !__counter[__i].empty()) {
 _S_merge(__counter[__i], __carry, __comp);
 __carry.swap(__counter[__i++]);
      }
      __carry.swap(__counter[__i]);
      if (__i == __fill) ++__fill;
    }

    for (int __i = 1; __i < __fill; ++__i)
      _S_merge(__counter[__i], __counter[__i-1], __comp);
    __that.swap(__counter[__fill-1]);
  }
}




}
# 557 "c:/marmalade/7.5/s3e/h/std/c++/stl/_list.h" 2
# 40 "c:/marmalade/7.5/s3e/h/std/c++/list" 2







# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_epilog.h" 1
# 10 "c:/marmalade/7.5/s3e/h/std/c++/stl/_epilog.h"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/config/_epilog.h" 1
# 11 "c:/marmalade/7.5/s3e/h/std/c++/stl/_epilog.h" 2



# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_config_compat_post.h" 1
# 15 "c:/marmalade/7.5/s3e/h/std/c++/stl/_epilog.h" 2
# 48 "c:/marmalade/7.5/s3e/h/std/c++/list" 2
# 17 "c:/Marmalade/7.5/examples/GameTutorial/CPP/Stage4/source/timer.h" 2

class TimerManager;
# 40 "c:/Marmalade/7.5/examples/GameTutorial/CPP/Stage4/source/timer.h"
class Timer
{
public:
    typedef void (*Callback)(Timer* pTimer, void* userData);

protected:
    unsigned int m_NameHash;
    TimerManager* m_Manager;
    float m_Length;
    float m_TimeLeft;
    Callback m_OnTimeout;
    void* m_UserData;
    int m_RepeatCount;
    bool m_Paused;

public:
    void setManager(TimerManager* manager) { m_Manager = manager; }
    unsigned int getNameHash() const { return m_NameHash; }
    void setLength(float length) { m_Length = length; m_TimeLeft = length; }
    void setOnTimeout(Callback callback) { m_OnTimeout = callback; }
    float getLength() const { return m_Length; }
    float getTimeLeft() const { return m_TimeLeft; }
    void setRepeatCount(int count) { m_RepeatCount = count; }
    bool isPaused() const { return m_Paused; }

public:
    Timer() : m_Manager(0), m_Length(0), m_TimeLeft(0), m_OnTimeout(0), m_UserData(0), m_RepeatCount(1), m_Paused(false) {}
    Timer(float length, int repeat_count = 1, Callback on_timeout = 0, void* user_data = 0);
# 78 "c:/Marmalade/7.5/examples/GameTutorial/CPP/Stage4/source/timer.h"
    bool Update(float deltaTime = 0.0f);






    void Pause();






    void Resume();

};
# 103 "c:/Marmalade/7.5/examples/GameTutorial/CPP/Stage4/source/timer.h"
class TimerManager
{
protected:
    _STL::list<Timer*> m_Timers;

public:
    TimerManager();
    ~TimerManager();
# 119 "c:/Marmalade/7.5/examples/GameTutorial/CPP/Stage4/source/timer.h"
    void Update(float deltaTime = 0.0f);







    void Add(Timer* timer);
# 136 "c:/Marmalade/7.5/examples/GameTutorial/CPP/Stage4/source/timer.h"
    void Cancel(Timer* timer);






    void Clear();
# 154 "c:/Marmalade/7.5/examples/GameTutorial/CPP/Stage4/source/timer.h"
    Timer* Find(const char* name);






    void Pause();






    void Resume();
};
# 14 "c:/Marmalade/7.5/examples/GameTutorial/CPP/Stage4/source/timer.cpp" 2
# 1 "c:/marmalade/7.5/modules/iwutil/h/IwHashString.h" 1
       
# 17 "c:/marmalade/7.5/modules/iwutil/h/IwHashString.h"
# 1 "c:/marmalade/7.5/modules/iwutil/h/IwString.h" 1
# 19 "c:/marmalade/7.5/modules/iwutil/h/IwString.h"
# 1 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h" 1
# 16 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h"
# 1 "c:/marmalade/7.5/s3e/h/s3eDebug.h" 1
# 15 "c:/marmalade/7.5/s3e/h/s3eDebug.h"
# 1 "c:/marmalade/7.5/s3e/h/s3eTypes.h" 1
# 16 "c:/marmalade/7.5/s3e/h/s3eDebug.h" 2
# 56 "c:/marmalade/7.5/s3e/h/s3eDebug.h"
typedef enum s3eDebugProperty
{



    S3E_DEBUG_TRACE_ENABLED = 0,





    S3E_DEBUG_TRACE_TO_FILE = 1,




    S3E_DEBUG_ASSERT_ENABLED = 2,





    S3E_DEBUG_AVAILABLE = 3,




    S3E_DEBUG_FONT_SCALE = 4,




    S3E_DEBUG_FONT_WIDTH = 5,




    S3E_DEBUG_FONT_HEIGHT = 6

} s3eDebugProperty;
# 113 "c:/marmalade/7.5/s3e/h/s3eDebug.h"
extern "C" int32 s3eDebugGetInt(s3eDebugProperty property);
# 131 "c:/marmalade/7.5/s3e/h/s3eDebug.h"
extern "C" s3eResult s3eDebugSetInt(s3eDebugProperty property, int32 value);







typedef enum s3eDebugCallback
{
# 155 "c:/marmalade/7.5/s3e/h/s3eDebug.h"
    S3E_DEBUG_ASSERT = 0,
# 170 "c:/marmalade/7.5/s3e/h/s3eDebug.h"
    S3E_DEBUG_ERROR = 1,

    S3E_DEBUG_CALLBACK_MAX
} s3eDebugCallback;
# 198 "c:/marmalade/7.5/s3e/h/s3eDebug.h"
extern "C" s3eResult s3eDebugRegister(s3eDebugCallback cbid, s3eCallback fn, void* userData);
# 215 "c:/marmalade/7.5/s3e/h/s3eDebug.h"
extern "C" s3eResult s3eDebugUnRegister(s3eDebugCallback cbid, s3eCallback fn);
# 224 "c:/marmalade/7.5/s3e/h/s3eDebug.h"
typedef enum s3eDebugError
{
    S3E_DEBUG_ERR_NONE = 0,
    S3E_DEBUG_ERR_PARAM = 1,
    S3E_DEBUG_ERR_TOO_MANY = 2,
    S3E_DEBUG_ERR_ALREADY_REG = 3,
    S3E_DEBUG_ERR_NOT_FOUND = 4
} s3eDebugError;
# 244 "c:/marmalade/7.5/s3e/h/s3eDebug.h"
extern "C" s3eDebugError s3eDebugGetError();
# 257 "c:/marmalade/7.5/s3e/h/s3eDebug.h"
extern "C" const char* s3eDebugGetErrorString();

typedef enum s3eErrorShowResult
{

    S3E_ERROR_SHOW_CONTINUE = 0,

    S3E_ERROR_SHOW_STOP = 1,

    S3E_ERROR_SHOW_IGNORE = 2,





    S3E_ERROR_SHOW_AGAIN = 3
} s3eErrorShowResult;




typedef enum s3eMessageType
{





    S3E_MESSAGE_CONTINUE = 0,





    S3E_MESSAGE_CONTINUE_STOP = 1,






    S3E_MESSAGE_CONTINUE_STOP_IGNORE = 2
} s3eMessageType;







extern "C" s3eBool s3eDebugIsDebuggerPresent();
# 323 "c:/marmalade/7.5/s3e/h/s3eDebug.h"
extern "C" void s3eDebugOutputString(const char* pStr);
# 335 "c:/marmalade/7.5/s3e/h/s3eDebug.h"
extern "C" s3eErrorShowResult s3eDebugErrorShow(s3eMessageType type, const char* string);






extern "C" s3eErrorShowResult s3eDebugErrorPrintf(const char* fmt, ...)

__attribute__((format(printf, 1, 2)))

;
# 360 "c:/marmalade/7.5/s3e/h/s3eDebug.h"
extern "C" s3eErrorShowResult s3eDebugAssertShow(s3eMessageType type, const char* string);
# 373 "c:/marmalade/7.5/s3e/h/s3eDebug.h"
extern "C" void s3eDebugTraceLine(const char* string);






extern "C" int s3eDebugTracePrintf(const char* fmt, ...)

__attribute__((format(printf, 1, 2)))

;






extern "C" void s3eDebugTraceClearFile();
# 400 "c:/marmalade/7.5/s3e/h/s3eDebug.h"
extern "C" void s3eDebugTraceFlush();
# 425 "c:/marmalade/7.5/s3e/h/s3eDebug.h"
extern "C" void s3eDebugPrint(int x, int y, const char* string, s3eBool wrap);






extern "C" void s3eDebugPrintf(int x, int y, s3eBool wrap, const char* fmt, ...)

__attribute__((format(printf, 4, 5)))

;







extern "C" s3eBool s3eDebugTraceChannelSwitch(const char* channel, s3eBool new_state);
# 17 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h" 2
# 1 "c:/marmalade/7.5/s3e/h/s3eDevice.h" 1
# 57 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
typedef enum s3eDeviceError
{
    S3E_DEVICE_ERR_NONE = 0,
    S3E_DEVICE_ERR_PARAM = 1,
    S3E_DEVICE_ERR_TOO_MANY = 2,
    S3E_DEVICE_ERR_ALREADY_REG = 3,
    S3E_DEVICE_ERR_NOT_FOUND = 4,
    S3E_DEVICE_ERR_UNAVAIL = 5,
    S3E_DEVICE_ERR_DEVICE = 6,
    S3E_DEVICE_ERR_UNSUPPORTED = 7,
    S3E_DEVICE_ERR_MEM = 8,
    S3E_DEVICE_ERR_GENERIC = 9,
    S3E_DEVICE_ERR_INVALID_DRIVE = 10,
    S3E_DEVICE_ERR_INVALID_PATH = 11
} s3eDeviceError;
# 84 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
extern "C" s3eDeviceError s3eDeviceGetError();
# 98 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
extern "C" const char* s3eDeviceGetErrorString();
# 107 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
typedef enum s3eDeviceFPUType
{
    S3E_DEVICE_FPU_NONE = 0,
    S3E_DEVICE_FPU_VFP = 1,
    S3E_DEVICE_FPU_VFPV3 = 2,
    S3E_DEVICE_FPU_NEON = 3
} s3eDeviceFPUType;






typedef enum s3eDeviceProperty
{







    S3E_DEVICE_OS = 0,





    S3E_DEVICE_CLASS = 1,
# 155 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_ID = 2,
# 175 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_PHONE_NUMBER = 3,





    S3E_DEVICE_LANGUAGE = 4,






    S3E_DEVICE_STATE = 5,
# 201 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_FREE_RAM = 6,
# 214 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_TOTAL_RAM = 7,
# 233 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_ARCHITECTURE = 8,
# 243 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_S3E_VERSION = 9,
# 254 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_BATTERY_LEVEL = 10,






    S3E_DEVICE_LEFT_SOFTKEY_IS_BACK = 11,
# 273 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_MAINS_POWER = 12,
# 282 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_OS_VERSION = 13,
# 300 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_CHIPSET = 14,
# 309 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_EXIT_CODE = 15,
# 327 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_FPU = 16,





    S3E_DEVICE_BACK_SOFTKEY_POSITION = 17,





    S3E_DEVICE_ADVANCE_SOFTKEY_POSITION = 18,
# 350 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_SDK_VERSION = 19,
# 359 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_LOCALE = 20,





    S3E_DEVICE_NAME = 21,







    S3E_DEVICE_SUPPORTS_SIGNAL_HANDLING = 22,







    S3E_DEVICE_EXIT_SIGNAL = 23,
# 401 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_PROXIMITY = 24,
# 438 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_UNIQUE_ID = 25,
# 461 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_IMSI = 26,
# 479 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_SILENT_MODE = 27,




    S3E_DEVICE_NUM_CPU_CORES = 28,
# 498 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_MEM_TOTAL = 29,
# 522 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_MEM_FREE = 30,





    S3E_DEVICE_TIMEZONE = 31,
# 546 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_3D_MODE = 32,
# 556 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_PROCESS_ID = 33,





    S3E_DEVICE_SUPPORTS_SUSPEND_RESUME = 34,





    S3E_DEVICE_DX_FEATURE_LEVEL = 35,




    S3E_DEVICE_TIMEZONE_STD = 36,




    S3E_DEVICE_TIMEZONE_DST = 37,
# 587 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_RUNTIME = 38,

} s3eDeviceProperty;






typedef enum s3eDeviceLicPlatID
{
    S3E_LICPLAT_ID_NONE = 0x0000,


    S3E_LICPLAT_ID_WINDOWS = 0x0001,

    S3E_LICPLAT_LINUX = 0x0002,

    S3E_LICPLAT_OSX = 0x0004,


    S3E_LICPLAT_IPHONE = 0x0008,

    S3E_LICPLAT_ANDROID = 0x0010,

    S3E_LICPLAT_QNX = 0x0020,

    S3E_LICPLAT_ROKU = 0x0040,

    S3E_LICPLAT_WP8 = 0x0080,

    S3E_LICPLAT_TIZEN = 0x0100,

    S3E_LICPLAT_WS8 = 0x0200,

    S3E_LICPLAT_LG = 0x0400,

    S3E_LICPLAT_UNSET = 0x10000000,
    S3E_LICPLAT_ALL = 0x7FFFFFFF
} s3eDeviceLicPlatID;







typedef enum s3eDeviceOSID
{
    S3E_OS_ID_NONE = 0,


    S3E_OS_ID_LG = 1,

    S3E_OS_ID_WINDOWS = 3,

    S3E_OS_ID_LINUX = 5,

    S3E_OS_ID_ARM_SEMIH = 8,

    S3E_OS_ID_OSX = 13,

    S3E_OS_ID_IPHONE = 14,

    S3E_OS_ID_ANDROID = 19,

    S3E_OS_ID_QNX = 24,

    S3E_OS_ID_ROKU = 25,

    S3E_OS_ID_WP8 = 26,

    S3E_OS_ID_TIZEN = 27,

    S3E_OS_ID_WS8 = 28,

    S3E_OS_ID_WS81 = 29,

    S3E_OS_ID_WP81 = 30,

    S3E_OS_ID_LAST = 31,







    S3E_OS_ID_BREW = 2,

    S3E_OS_ID_WINMOBILE = 4,

    S3E_OS_ID_WIPI = 6,

    S3E_OS_ID_NDS = 7,

    S3E_OS_ID_NUCLEUS = 9,

    S3E_OS_ID_NGI = 10,

    S3E_OS_ID_WINCE = 11,

    S3E_OS_ID_SHARPEMP = 12,

    S3E_OS_ID_UIQ = 15,

    S3E_OS_ID_PS3 = 16,

    S3E_OS_ID_X360 = 17,

    S3E_OS_ID_WEBOS = 20,

    S3E_OS_ID_PSP = 21,

    S3E_OS_ID_WII = 22,

    S3E_OS_ID_MEEGO = 23,

} s3eDeviceOSID;







typedef enum s3eDeviceClassID
{
    S3E_DEVICE_CLASS_UNKNOWN = 0,

    S3E_DEVICE_CLASS_WINDOWS_GENERIC = 3000,
    S3E_DEVICE_CLASS_WINDOWS_PHONE = 3010,
    S3E_DEVICE_CLASS_WINDOWS_STORE = 3020,
    S3E_DEVICE_CLASS_LINUX_GENERIC = 5000,
    S3E_DEVICE_CLASS_LINUX_DESKTOP = 5001,
    S3E_DEVICE_CLASS_LINUX_EMBED = 5002,
    S3E_DEVICE_CLASS_ARM_SEMIH_GENERIC = 8000,
    S3E_DEVICE_CLASS_OSX_DESKTOP = 11000,
    S3E_DEVICE_CLASS_IPHONE = 12000,
    S3E_DEVICE_CLASS_ANDROID_GENERIC = 16000,
    S3E_DEVICE_CLASS_QNX = 19000,
    S3E_DEVICE_CLASS_TIZEN_GENERIC = 20000,

    S3E_DEVICE_CLASS_SYMBIAN_GENERIC = 1000,
    S3E_DEVICE_CLASS_SYMBIAN_SERIES60 = 1001,
    S3E_DEVICE_CLASS_SYMBIAN_SERIES60_EMULATOR = 1002,
    S3E_DEVICE_CLASS_SYMBIAN_UIQ = 1003,
    S3E_DEVICE_CLASS_SYMBIAN_UIQ_EMULATOR = 1004,
    S3E_DEVICE_CLASS_BREW_GENERIC = 2000,
    S3E_DEVICE_CLASS_BREW_QCIF_3G = 2001,
    S3E_DEVICE_CLASS_BREW_QCIF_25G = 2002,
    S3E_DEVICE_CLASS_BREW_SQCIF_25G = 2003,
    S3E_DEVICE_CLASS_BREW_QVGA_3G = 2004,
    S3E_DEVICE_CLASS_WINCE_GENERIC = 4000,
    S3E_DEVICE_CLASS_WINMOBILE_SP = 4001,
    S3E_DEVICE_CLASS_WINMOBILE_PPC = 4002,
    S3E_DEVICE_CLASS_WIPI_GENERIC = 6000,
    S3E_DEVICE_CLASS_NDS_GENERIC = 7000,
    S3E_DEVICE_CLASS_NDS_NDSI = 7001,
    S3E_DEVICE_CLASS_NUCLEUS_GENERIC = 9000,
    S3E_DEVICE_CLASS_NGI_GENERIC = 10000,
    S3E_DEVICE_CLASS_PS3 = 13000,
    S3E_DEVICE_CLASS_X360 = 14000,
    S3E_DEVICE_CLASS_BADA_GENERIC = 15000,
    S3E_DEVICE_CLASS_PSP = 17000,
    S3E_DEVICE_CLASS_WII = 18000

} s3eDeviceClassID;






typedef enum s3eDeviceRuntimeID
{
    S3E_DEVICE_RUNTIME_UNKNOWN = 0,
    S3E_DEVICE_RUNTIME_DALVIK = 1,
    S3E_DEVICE_RUNTIME_ART = 2,

    S3E_DEVICE_RUNTIME_WINDOWS_PHONE = 3,
    S3E_DEVICE_RUNTIME_WINDOWS = 4,

} s3eDeviceRuntimeID;




typedef enum s3eDeviceLanguage
{
    S3E_DEVICE_LANGUAGE_UNKNOWN = 0,
    S3E_DEVICE_LANGUAGE_ENGLISH = 1,
    S3E_DEVICE_LANGUAGE_FRENCH = 2,
    S3E_DEVICE_LANGUAGE_GERMAN = 3,
    S3E_DEVICE_LANGUAGE_SPANISH = 4,
    S3E_DEVICE_LANGUAGE_ITALIAN = 5,
    S3E_DEVICE_LANGUAGE_PORTUGUESE = 6,
    S3E_DEVICE_LANGUAGE_DUTCH = 7,
    S3E_DEVICE_LANGUAGE_TURKISH = 8,
    S3E_DEVICE_LANGUAGE_CROATIAN = 9,
    S3E_DEVICE_LANGUAGE_CZECH = 10,
    S3E_DEVICE_LANGUAGE_DANISH = 11,
    S3E_DEVICE_LANGUAGE_FINNISH = 12,
    S3E_DEVICE_LANGUAGE_HUNGARIAN = 13,
    S3E_DEVICE_LANGUAGE_NORWEGIAN = 14,
    S3E_DEVICE_LANGUAGE_POLISH = 15,
    S3E_DEVICE_LANGUAGE_RUSSIAN = 16,
    S3E_DEVICE_LANGUAGE_SERBIAN = 17,
    S3E_DEVICE_LANGUAGE_SLOVAK = 18,
    S3E_DEVICE_LANGUAGE_SLOVENIAN = 19,
    S3E_DEVICE_LANGUAGE_SWEDISH = 20,
    S3E_DEVICE_LANGUAGE_UKRAINIAN = 21,
    S3E_DEVICE_LANGUAGE_GREEK = 22,
    S3E_DEVICE_LANGUAGE_JAPANESE = 23,
    S3E_DEVICE_LANGUAGE_SIMPL_CHINESE = 24,
    S3E_DEVICE_LANGUAGE_TRAD_CHINESE = 25,
    S3E_DEVICE_LANGUAGE_KOREAN = 26,
    S3E_DEVICE_LANGUAGE_ICELANDIC = 27,
    S3E_DEVICE_LANGUAGE_FLEMISH = 28,
    S3E_DEVICE_LANGUAGE_THAI = 29,
    S3E_DEVICE_LANGUAGE_AFRIKAANS = 30,
    S3E_DEVICE_LANGUAGE_ALBANIAN = 31,
    S3E_DEVICE_LANGUAGE_AMHARIC = 32,
    S3E_DEVICE_LANGUAGE_ARABIC = 33,
    S3E_DEVICE_LANGUAGE_ARMENIAN = 34,
    S3E_DEVICE_LANGUAGE_AZERBAIJANI = 35,
    S3E_DEVICE_LANGUAGE_TAGALOG = 36,
    S3E_DEVICE_LANGUAGE_BELARUSSIAN = 37,
    S3E_DEVICE_LANGUAGE_BENGALI = 38,
    S3E_DEVICE_LANGUAGE_BULGARIAN = 39,
    S3E_DEVICE_LANGUAGE_BURMESE = 40,
    S3E_DEVICE_LANGUAGE_CATALAN = 41,
    S3E_DEVICE_LANGUAGE_ESTONIAN = 42,
    S3E_DEVICE_LANGUAGE_FARSI = 43,
    S3E_DEVICE_LANGUAGE_GAELIC = 44,
    S3E_DEVICE_LANGUAGE_GEORGIAN = 45,
    S3E_DEVICE_LANGUAGE_GUJARATI = 46,
    S3E_DEVICE_LANGUAGE_HEBREW = 47,
    S3E_DEVICE_LANGUAGE_HINDI = 48,
    S3E_DEVICE_LANGUAGE_INDONESIAN = 49,
    S3E_DEVICE_LANGUAGE_IRISH = 50,
    S3E_DEVICE_LANGUAGE_KANNADA = 51,
    S3E_DEVICE_LANGUAGE_KAZAKH = 52,
    S3E_DEVICE_LANGUAGE_KHMER = 53,
    S3E_DEVICE_LANGUAGE_LAO = 54,
    S3E_DEVICE_LANGUAGE_LATVIAN = 55,
    S3E_DEVICE_LANGUAGE_LITHUANIAN = 56,
    S3E_DEVICE_LANGUAGE_MACEDONIAN = 57,
    S3E_DEVICE_LANGUAGE_MALAY = 58,
    S3E_DEVICE_LANGUAGE_MALAYALAM = 59,
    S3E_DEVICE_LANGUAGE_MARATHI = 60,
    S3E_DEVICE_LANGUAGE_MOLDOVIAN = 61,
    S3E_DEVICE_LANGUAGE_MONGOLIAN = 62,
    S3E_DEVICE_LANGUAGE_PUNJABI = 63,
    S3E_DEVICE_LANGUAGE_ROMANIAN = 64,
    S3E_DEVICE_LANGUAGE_SINHALESE = 65,
    S3E_DEVICE_LANGUAGE_SOMALI = 66,
    S3E_DEVICE_LANGUAGE_SWAHILI = 67,
    S3E_DEVICE_LANGUAGE_TAJIK = 68,
    S3E_DEVICE_LANGUAGE_TAMIL = 69,
    S3E_DEVICE_LANGUAGE_TELUGU = 70,
    S3E_DEVICE_LANGUAGE_TIBETAN = 71,
    S3E_DEVICE_LANGUAGE_TIGRINYA = 72,
    S3E_DEVICE_LANGUAGE_TURKMEN = 73,
    S3E_DEVICE_LANGUAGE_URDU = 74,
    S3E_DEVICE_LANGUAGE_UZBEK = 75,
    S3E_DEVICE_LANGUAGE_VIETNAMESE = 76,
    S3E_DEVICE_LANGUAGE_WELSH = 77,
    S3E_DEVICE_LANGUAGE_ZULU = 78
} s3eDeviceLanguage;
# 869 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
typedef enum s3eDeviceArchitecture
{
    S3E_DEVICE_ARCHITECTURE_UNKNOWN = -1,


    S3E_DEVICE_ARCHITECTURE_ARM4T = 0,
    S3E_DEVICE_ARCHITECTURE_ARM4 = 1,
    S3E_DEVICE_ARCHITECTURE_ARM5T = 2,
    S3E_DEVICE_ARCHITECTURE_ARM5TE = 3,
    S3E_DEVICE_ARCHITECTURE_ARM5TEJ = 4,
    S3E_DEVICE_ARCHITECTURE_ARM6 = 5,
    S3E_DEVICE_ARCHITECTURE_ARM6K = 6,
    S3E_DEVICE_ARCHITECTURE_ARM6T2 = 7,
    S3E_DEVICE_ARCHITECTURE_ARM6Z = 8,
    S3E_DEVICE_ARCHITECTURE_ARM7A = 12,
    S3E_DEVICE_ARCHITECTURE_ARM8A = 14,


    S3E_DEVICE_ARCHITECTURE_ARM8A_AARCH64 = 15,


    S3E_DEVICE_ARCHITECTURE_X86 = 9,
    S3E_DEVICE_ARCHITECTURE_PPC = 10,
    S3E_DEVICE_ARCHITECTURE_AMD64 = 11,
    S3E_DEVICE_ARCHITECTURE_MIPS = 13,

    S3E_DEVICE_ARCHITECTURE_MAX = 16
} s3eDeviceArchitecture;
# 905 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
typedef enum s3eDeviceSoftKeyPosition
{
    S3E_DEVICE_SOFTKEY_BOTTOM_LEFT = 0,
    S3E_DEVICE_SOFTKEY_BOTTOM_RIGHT = 1,
    S3E_DEVICE_SOFTKEY_TOP_RIGHT = 2,
    S3E_DEVICE_SOFTKEY_TOP_LEFT = 3
} s3eDeviceSoftKeyPosition;
# 946 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
extern "C" const char* s3eDeviceGetString(s3eDeviceProperty property);
# 981 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
extern "C" int32 s3eDeviceGetInt(s3eDeviceProperty property);
# 1001 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
extern "C" s3eResult s3eDeviceSetInt(s3eDeviceProperty property, int32 value);
# 1029 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
extern "C" int64 s3eDeviceYield(int32 ms =0);
# 1051 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
extern "C" void s3eDeviceUnYield();
# 1079 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
extern "C" void s3eDeviceYieldUntilEvent(int32 ms =0x7fffffffL);
# 1114 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
extern "C" s3eResult s3eDeviceExecPushNext(const char* filename, const char* config_prepend =__null, const char* config_append =__null);
# 1130 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
extern "C" void s3eDeviceExit(int code =0) __attribute__ ((noreturn));






typedef enum s3eDeviceState
{




    S3E_DEVICE_STATE_PAUSED = 3,





    S3E_DEVICE_STATE_EXITING = 4,




    S3E_DEVICE_STATE_RUNNING = 5
} s3eDeviceState;
# 1167 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
typedef enum s3eDeviceCallback
{
# 1180 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_PAUSE = 0,
# 1192 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_UNPAUSE = 1,
# 1204 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_EXIT = 2,
# 1220 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_VOL_UP = 17,
# 1236 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_VOL_DOWN = 18,
# 1254 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_MAINS_POWER_CHANGED = 20,
# 1266 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_BACKGROUND = 22,
# 1278 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_FOREGROUND = 23,
# 1295 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_NETWORK_ONLINE = 24,
# 1312 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_NETWORK_OFFLINE = 25,
# 1328 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_SIMULATOR_RESTART = 26,
# 1345 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_APPLICATION_ACTIVE = 27,
# 1362 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_APPLICATION_INACTIVE = 28,
# 1379 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_APPLICATION_FULLSCREEN = 29,
# 1396 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_APPLICATION_THUMBNAIL = 30,
# 1413 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_APPLICATION_INVISIBLE = 31,
# 1430 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_OBSCURED = 32,
# 1447 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    S3E_DEVICE_UNOBSCURED = 33,

    S3E_DEVICE_CALLBACK_MAX
} s3eDeviceCallback;
# 1468 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
typedef struct s3eDeviceVolChangeInfo
{





    s3eBool m_VolUp;
# 1493 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
    s3eBool m_OverrideDefaultBehaviour;
} s3eDeviceVolChangeInfo;





typedef struct s3eDeviceStateChangeInfo
{



    int32 m_State;
} s3eDeviceStateChangeInfo;
# 1528 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
extern "C" s3eResult s3eDeviceRegister(s3eDeviceCallback cbid, s3eCallback fn, void* userdata);
# 1548 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
extern "C" s3eResult s3eDeviceUnRegister(s3eDeviceCallback cbid, s3eCallback fn);







extern "C" void s3eDeviceRequestQuit();
# 1567 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
extern "C" s3eBool s3eDeviceCheckQuitRequest();
# 1577 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
extern "C" s3eBool s3eDeviceCheckPauseRequest();
# 1591 "c:/marmalade/7.5/s3e/h/s3eDevice.h"
extern "C" void s3eDeviceBacklightOn();


extern "C" s3eBool s3eDeviceNetworkCheckStart();


extern "C" s3eBool s3eDeviceNetworkCheckStop();


extern "C" void s3eDeviceLoaderCallStart(s3eBool lock, void* function);


extern "C" void s3eDeviceLoaderCallDone(s3eBool lock, void* function);


extern "C" void s3eDeviceAbort(void* pStack);
# 18 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h" 2
# 1 "c:/marmalade/7.5/modules/iwutil/h/IwCore.h" 1
# 19 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h" 2



# 1 "c:/marmalade/7.5/s3e/h/std/stdio.h" 1
# 23 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h" 2
# 1 "c:/marmalade/7.5/s3e/h/std/stdlib.h" 1
# 24 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h" 2
# 51 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h"
typedef void(*IwAssertTextCallback)(char* pBuffer);

extern "C" {

typedef s3eErrorShowResult(*IwAssertCallback)(const char* channel, const char* pExpr, const char* pFilename, int32 line, const char* message);
typedef s3eErrorShowResult(*IwErrorCallback)(const char* message);
# 65 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h"
 s3eBool IwDebugTraceIsChannelOn(const char* channel, s3eBool default_on);
# 74 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h"
void IwDebugTraceDisable(s3eBool disable);




 void IwDebugTraceSetTraceChannel(const char* channel);
# 91 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h"
 s3eBool IwDebugTraceChannelSwitch(const char* channel, s3eBool new_state);
# 101 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h"
 void IwDebugTraceLinePrintf(const char* fmt, ...)

__attribute__((format(printf, 1, 2)))

;






 void IwDebugTraceLineVPrintf(const char* fmt, va_list args);


 void IwDebugAssertSetUID(uint32 n);







 s3eBool IwDebugAssertIsChannelOn(const char* channel);







 void IwDebugClearConfigCache();
# 141 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h"
 void IwDebugAssertSetMessage(const char* fmt, ...)

__attribute__((format(printf, 1, 2)))

;
# 156 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h"
 void IwDebugAssertSetSolution(const char* fmt, ...)

__attribute__((format(printf, 1, 2)))

;







 s3eErrorShowResult IwDebugAssertShow(const char* pExpr, const char* pFilename, int32 line, uint8 ignorable);






 IwAssertTextCallback IwAssertRegisterTextCallback(IwAssertTextCallback fn);






 IwAssertCallback IwAssertRegisterCallback(IwAssertCallback fn);
# 192 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h"
 s3eErrorShowResult IwDebugErrorShow(const char* Args, ...)

__attribute__((format(printf, 1, 2)))

;






 IwErrorCallback IwDebugErrorRegisterCallback(IwErrorCallback fn);

}
# 347 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h"
    static inline void IwDebugExit()
    {
        abort();
    }
# 581 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/typeinfo" 1
# 21 "c:/marmalade/7.5/s3e/h/std/c++/typeinfo"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_prolog.h" 1
# 16 "c:/marmalade/7.5/s3e/h/std/c++/stl/_prolog.h"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/config/_prolog.h" 1
# 17 "c:/marmalade/7.5/s3e/h/std/c++/stl/_prolog.h" 2
# 22 "c:/marmalade/7.5/s3e/h/std/c++/typeinfo" 2





# 1 "c:/marmalade/7.5/s3e/h/std/c++/typeinfo.h" 1
# 20 "c:/marmalade/7.5/s3e/h/std/c++/typeinfo.h"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/exception" 1
# 75 "c:/marmalade/7.5/s3e/h/std/c++/exception"
namespace _STL {


using __std_alias::exception;
using __std_alias::bad_exception;
# 106 "c:/marmalade/7.5/s3e/h/std/c++/exception"
}
# 21 "c:/marmalade/7.5/s3e/h/std/c++/typeinfo.h" 2
namespace std
{
    using _STL::exception;
}
# 1 "c:/marmalade/7.5/s3e/h/std/c++/typeinfo_gcc" 1
# 39 "c:/marmalade/7.5/s3e/h/std/c++/typeinfo_gcc"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/exception" 1
# 75 "c:/marmalade/7.5/s3e/h/std/c++/exception"
namespace _STL {


using __std_alias::exception;
using __std_alias::bad_exception;
# 106 "c:/marmalade/7.5/s3e/h/std/c++/exception"
}
# 40 "c:/marmalade/7.5/s3e/h/std/c++/typeinfo_gcc" 2

#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 85 "c:/marmalade/7.5/s3e/h/std/c++/typeinfo_gcc"
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);

  protected:
    const char *__name;

  protected:
    explicit type_info(const char *__n): __name(__n) { }

  public:



    const char* name() const;
# 133 "c:/marmalade/7.5/s3e/h/std/c++/typeinfo_gcc"
    bool before(const type_info& __arg) const
    { return __name < __arg.__name; }
    bool operator==(const type_info& __arg) const
    { return __name == __arg.__name; }

    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }


  public:
# 165 "c:/marmalade/7.5/s3e/h/std/c++/typeinfo_gcc"
    virtual bool __is_pointer_p() const;

    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  };






  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }


    virtual ~bad_cast() throw();

    virtual const char* what() const throw();
  };


  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }


    virtual ~bad_typeid() throw();

    virtual const char* what() const throw();
  };
}

#pragma GCC visibility pop

}
# 26 "c:/marmalade/7.5/s3e/h/std/c++/typeinfo.h" 2
# 28 "c:/marmalade/7.5/s3e/h/std/c++/typeinfo" 2
# 43 "c:/marmalade/7.5/s3e/h/std/c++/typeinfo"
namespace _STL {



using __std_alias::type_info;



using __std_alias::bad_typeid;
# 61 "c:/marmalade/7.5/s3e/h/std/c++/typeinfo"
using __std_alias::bad_cast;


}
# 78 "c:/marmalade/7.5/s3e/h/std/c++/typeinfo"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_epilog.h" 1
# 10 "c:/marmalade/7.5/s3e/h/std/c++/stl/_epilog.h"
# 1 "c:/marmalade/7.5/s3e/h/std/c++/config/_epilog.h" 1
# 11 "c:/marmalade/7.5/s3e/h/std/c++/stl/_epilog.h" 2



# 1 "c:/marmalade/7.5/s3e/h/std/c++/stl/_config_compat_post.h" 1
# 15 "c:/marmalade/7.5/s3e/h/std/c++/stl/_epilog.h" 2
# 79 "c:/marmalade/7.5/s3e/h/std/c++/typeinfo" 2
# 582 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h" 2


template <class _To, class _From>
_To IwSafeCast(_From from)
{

    if (from != __null && dynamic_cast<_To>(from) == __null)
        {
            const _STL::type_info& srctype = typeid(*from);
            const char* src = srctype.name();
            const char* target = typeid(_To).name();
            do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("CORE")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Mis-casting pointer: 0x%p is a pointer to type '%s', which is not derived from '%s'", from, src, target); switch (IwDebugAssertShow("false",
 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h"
# 593 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h"
            ,
 594
# 593 "c:/marmalade/7.5/modules/iwutil/h/IwDebug.h"
            , (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do { if (s3eDebugIsDebuggerPresent()) __asm__ (" int $3 "); } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0)
                               ;
    }

    return static_cast <_To> (from);
}
# 20 "c:/marmalade/7.5/modules/iwutil/h/IwString.h" 2




# 1 "c:/marmalade/7.5/s3e/h/std/string.h" 1
# 25 "c:/marmalade/7.5/modules/iwutil/h/IwString.h" 2



# 1 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h" 1
       
# 29 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
# 1 "c:/marmalade/7.5/s3e/h/s3eFile.h" 1
# 52 "c:/marmalade/7.5/s3e/h/s3eFile.h"
typedef struct s3eFile s3eFile;
# 85 "c:/marmalade/7.5/s3e/h/s3eFile.h"
typedef enum s3eFileSeekOrigin
{
    S3E_FILESEEK_SET = 0,
    S3E_FILESEEK_CUR = 1,
    S3E_FILESEEK_END = 2
} s3eFileSeekOrigin;




typedef struct s3eFileList s3eFileList;
# 116 "c:/marmalade/7.5/s3e/h/s3eFile.h"
typedef enum s3eFileProperty
{






    S3E_FILE_ROM_EXISTS = 1,





    S3E_FILE_BYTES_TOTAL = 2,




    S3E_FILE_BYTES_FREE = 3
} s3eFileProperty;
# 146 "c:/marmalade/7.5/s3e/h/s3eFile.h"
typedef enum s3eFileStats
{







    S3E_FILE_ISFILE = 0,







    S3E_FILE_ISDIR = 1,






    S3E_FILE_ISUSER = 2,
# 183 "c:/marmalade/7.5/s3e/h/s3eFile.h"
    S3E_FILE_ISWRITABLE = 3,





    S3E_FILE_SIZE = 4,
# 199 "c:/marmalade/7.5/s3e/h/s3eFile.h"
    S3E_FILE_MODIFIED_DATE = 5,
# 211 "c:/marmalade/7.5/s3e/h/s3eFile.h"
    S3E_FILE_DRIVE_BYTES_FREE = 6,
# 220 "c:/marmalade/7.5/s3e/h/s3eFile.h"
    S3E_FILE_DRIVE = 7,
# 229 "c:/marmalade/7.5/s3e/h/s3eFile.h"
    S3E_FILE_DRIVE_BYTES_TOTAL = 8,






    S3E_FILE_REAL_PATH = 9,
} s3eFileStats;
# 255 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" int32 s3eFileGetInt(s3eFileProperty property);
# 280 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" int64 s3eFileGetFileInt(const char* filename, s3eFileStats stat);
# 305 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" char* s3eFileGetFileString(const char* filename, s3eFileStats stat, char* str, int len);
# 314 "c:/marmalade/7.5/s3e/h/s3eFile.h"
typedef enum s3eFileError
{
    S3E_FILE_ERR_NONE = 0,
    S3E_FILE_ERR_PARAM = 1,
    S3E_FILE_ERR_TOO_MANY = 2,
    S3E_FILE_ERR_ALREADY_REG = 3,
    S3E_FILE_ERR_NOT_FOUND = 4,
    S3E_FILE_ERR_UNAVAIL = 5,
    S3E_FILE_ERR_DEVICE = 6,
    S3E_FILE_ERR_UNSUPPORTED = 7,
    S3E_FILE_ERR_MEM = 8,
    S3E_FILE_ERR_GENERIC = 9,
    S3E_FILE_ERR_INVALID_DRIVE = 10,
    S3E_FILE_ERR_INVALID_PATH = 11,
    S3E_FILE_ERR_DATA = 12,

    S3E_FILE_ERR_INVALID_MODE = 1000,
    S3E_FILE_ERR_EXISTS = 1001,
    S3E_FILE_ERR_NOT_EMPTY = 1002,
    S3E_FILE_ERR_ACCESS = 1003,
    S3E_FILE_ERR_NO_MORE = 1004,
    S3E_FILE_ERR_EOF = 1005
} s3eFileError;
# 349 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" s3eFileError s3eFileGetError();
# 363 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" const char* s3eFileGetErrorString();
# 414 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" s3eFile* s3eFileOpen(const char* filename, const char* mode);
# 433 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" s3eFile* s3eFileOpenFromMemory(void* buffer, size_t bufferLen);
# 450 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileClose(s3eFile* file);
# 471 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileFlush(s3eFile* file);
# 502 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" size_t s3eFileRead(void* buffer, size_t elemSize, size_t noElems, s3eFile* file);
# 529 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" size_t s3eFileWrite(const void* buffer, size_t elemSize, size_t noElems, s3eFile* file);
# 543 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" int32 s3eFilePrintf(s3eFile* f, const char *fmt, ...);
# 563 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" int32 s3eFileGetChar(s3eFile* file);
# 586 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" int32 s3eFilePutChar(char c, s3eFile* file);
# 624 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" char* s3eFileReadString(char* string, uint32 maxLen, s3eFile* file);
# 647 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" s3eBool s3eFileEOF(s3eFile* file);
# 682 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileSeek(s3eFile* file, long int offset, s3eFileSeekOrigin origin);
# 698 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" long int s3eFileTell(s3eFile* file);
# 715 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" int32 s3eFileGetSize(s3eFile* file);
# 741 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileMakeDirectory(const char* dirName);
# 766 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileDeleteDirectory(const char* dirName);
# 782 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" s3eBool s3eFileCheckExists(const char* filename);
# 816 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileRename(const char* src, const char* dest);
# 841 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileDelete(const char* filename);
# 869 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileTruncate(const char* filename, size_t length);
# 879 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" uint64 s3eFileGetLastWriteTime(const char* filename);
# 908 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" s3eFileList* s3eFileListDirectory(const char* dirName);
# 930 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileListNext(s3eFileList* handle, char* filename, int filenameLen);
# 945 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileListClose(s3eFileList* handle);







typedef struct s3eUsrFile s3eUsrFile;
# 963 "c:/marmalade/7.5/s3e/h/s3eFile.h"
typedef s3eUsrFile*(*s3eUserOpenFn)(const char* filename, const char *mode);
# 975 "c:/marmalade/7.5/s3e/h/s3eFile.h"
typedef size_t (*s3eUserReadFn)(void* buffer, size_t elemLen, size_t noElems, s3eUsrFile *file);
# 987 "c:/marmalade/7.5/s3e/h/s3eFile.h"
typedef size_t (*s3eUserWriteFn)(const void* buffer, size_t elemLen, size_t noElems, s3eUsrFile *file);
# 996 "c:/marmalade/7.5/s3e/h/s3eFile.h"
typedef s3eBool (*s3eUserEOFFn)(s3eUsrFile* file);
# 1007 "c:/marmalade/7.5/s3e/h/s3eFile.h"
typedef s3eResult (*s3eUserSeekFn)(s3eUsrFile* file, long int offset, s3eFileSeekOrigin origin);
# 1016 "c:/marmalade/7.5/s3e/h/s3eFile.h"
typedef long int (*s3eUserTellFn)(s3eUsrFile* file);
# 1025 "c:/marmalade/7.5/s3e/h/s3eFile.h"
typedef s3eResult (*s3eUserCloseFn)(s3eUsrFile* file);




typedef struct s3eUsrFileList s3eUsrFileList;
# 1040 "c:/marmalade/7.5/s3e/h/s3eFile.h"
typedef s3eUsrFileList* (*s3eUserListDirFn)(const char* path);
# 1054 "c:/marmalade/7.5/s3e/h/s3eFile.h"
typedef s3eResult (*s3eUserListNextFn)(s3eUsrFileList* handle, char* filename, int filenameLen);
# 1064 "c:/marmalade/7.5/s3e/h/s3eFile.h"
typedef s3eResult (*s3eUserListCloseFn)(s3eUsrFileList* handle);
# 1074 "c:/marmalade/7.5/s3e/h/s3eFile.h"
typedef s3eResult (*s3eUserDeleteFn)(const char* filename);
# 1111 "c:/marmalade/7.5/s3e/h/s3eFile.h"
typedef struct
{
    s3eUserOpenFn m_Open;
    s3eUserReadFn m_Read;
    s3eUserEOFFn m_EOF;
    s3eUserSeekFn m_Seek;
    s3eUserTellFn m_Tell;
    s3eUserCloseFn m_Close;

    s3eUserListDirFn m_ListDir;
    s3eUserListNextFn m_ListNext;
    s3eUserListCloseFn m_ListClose;

    s3eUserWriteFn m_Write;
    s3eUserDeleteFn m_Delete;

    void* m_Reserved[5];
} s3eFileUserCallbacks;
# 1141 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileAddUserFileSys(s3eFileUserCallbacks* callbacks);
# 1151 "c:/marmalade/7.5/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileRemoveUserFileSys(s3eFileUserCallbacks* callbacks);





# 1 "c:/marmalade/7.5/s3e/h/legacy/s3eFile_legacy.h" 1
# 16 "c:/marmalade/7.5/s3e/h/legacy/s3eFile_legacy.h"
typedef enum s3eFilePath
{
    S3E_FILEPATH_ROM,
    S3E_FILEPATH_RAM,
    S3E_FILEPATH_MMC,
    S3E_FILEPATH_MAX
} s3eFilePath;
# 34 "c:/marmalade/7.5/s3e/h/legacy/s3eFile_legacy.h"
extern "C" uint64 s3eFileGetFree(s3eFilePath path);
# 1158 "c:/marmalade/7.5/s3e/h/s3eFile.h" 2
# 30 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h" 2

class CIwManaged;
class CIwTextParserITX;
# 50 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
typedef void(*IwSerialiseUserCallback)();





struct IwSerialiseContext
{
    bool read;
    uint32 base;
    s3eFile* handle;
    char filename[160];
    uint32 bytesRead;
    uint32 callbackPeriod;
    uint8 buffer[8];
    int32 headBit;
    uint32 version;
    uint16 versionUser;
    uint16 pad;
    IwSerialiseUserCallback callback;
};
extern IwSerialiseContext g_IwSerialiseContext;
extern int g_IwSerialiseContextValid;
# 87 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
enum IwSerialiseMode
{
    IW_SERIALISE_WRITE = 0,
    IW_SERIALISE_READ = 1
};
# 100 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
static inline bool IwSerialiseIsReading() {return g_IwSerialiseContext.read == true;}
# 109 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
static inline bool IwSerialiseIsWriting() {return g_IwSerialiseContext.read == false;}
# 120 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseSetUserVersion(uint16 v) {g_IwSerialiseContext.versionUser = v;}
# 129 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
static inline uint16 IwSerialiseGetUserVersion() {return g_IwSerialiseContext.versionUser;}







static inline bool IwIsSerialiseOpen(){return (g_IwSerialiseContextValid > 0);}
# 146 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
void IwSerialiseOpen(const char* filename, IwSerialiseMode mode, bool ram=false);
# 156 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseOpen(const char* filename, bool read, bool ram=false)
{
    IwSerialiseOpen(filename, read ? IW_SERIALISE_READ : IW_SERIALISE_WRITE, ram);
}






bool IwSerialiseExists(const char* filename, bool ram=false);







bool IwSerialiseEOF();
# 184 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
void IwSerialiseOpenFromMemory(void* pBuffer, int size, IwSerialiseMode mode);







static inline void IwSerialiseOpenFromMemory(void* pBuffer, int size, bool read)
{
    IwSerialiseOpenFromMemory(pBuffer, size, read ? IW_SERIALISE_READ : IW_SERIALISE_WRITE);
}






void IwSerialiseClose();






void IwSerialiseResetCallbackCount();






void IwSerialiseSetCallbackPeriod(uint32 p);






void IwSerialiseSetCallback(IwSerialiseUserCallback cb);
# 232 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
static inline void _SerialiseScalarType(IwSerialiseContext& c, void* var, int itemSize, int numItems)
{

    if (c.read == true)
        s3eFileRead(var, itemSize, numItems, c.handle);
    else
        s3eFileWrite(var, itemSize, numItems, c.handle);
# 260 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
}
# 271 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
void IwSerialiseDouble(double& var, int n=1, int numBits=sizeof(double)*8, int stride=sizeof(double));
# 282 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
void IwSerialiseFloat(float& var, int n=1, int numBits=sizeof(float)*8, int stride=sizeof(float));
# 293 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
void IwSerialiseUInt64(uint64& var, int n=1, int numBits=sizeof(uint64)*8, int stride=sizeof(uint64));
# 304 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
void IwSerialiseInt64(int64& var, int n=1, int numBits=sizeof(int64)*8-1, int stride=sizeof(int64));
# 316 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
void IwSerialiseUInt32(uint32& var, int n=1, int numBits=sizeof(uint32)*8, int stride=sizeof(uint32));
# 327 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
void IwSerialiseInt32(int32& var, int n=1, int numBits=sizeof(int32)*8-1, int stride=sizeof(int32));
# 338 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
void IwSerialiseUInt16(uint16& var, int n=1, int numBits=sizeof(uint16)*8, int stride=sizeof(uint16));
# 349 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
void IwSerialiseInt16(int16& var, int n=1, int numBits=sizeof(int16)*8-1, int stride=sizeof(int16));
# 360 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
void IwSerialiseUInt8(uint8& var, int n=1, int numBits=sizeof(uint8)*8, int stride=sizeof(uint8));
# 371 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
void IwSerialiseInt8(int8& var, int n=1, int numBits=sizeof(int8)*8-1, int stride=sizeof(int8));
# 382 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
void IwSerialiseChar(char& var, int n=1, int numBits=sizeof(int8)*8-1, int stride=sizeof(char));
# 393 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
void IwSerialiseBool(bool& var, int n=1, int numBits=1, int stride=sizeof(bool));
# 403 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
void IwSerialiseEnum(void* pVar);





template <class T, bool SGN>
void _IwSerialiseBitDepthRequired(T& var, int n, int stride, void(*CB1)(T&, int, int, int))
{

    uint32 mb;
    if (g_IwSerialiseContext.read == false)
    {
        T* pVal = &var;
        uint32 t = n;
        mb = 1;
        while(t-- && (mb < sizeof(T)*8))
        {
            T v = *pVal;
            pVal += stride / sizeof(T);
            if (SGN)
            {
                if (v & (1ul << ((sizeof(T)*8) - 1)))
                    v = ~v;
            }
            while((v >= ((T)1 << mb)) && (mb < sizeof(T)*8))
                mb++;
        }
    }

    IwSerialiseUInt32(mb, 1, 6);
    (CB1)(var, n, mb, stride);



}
# 451 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseCharBitDepthRequired(char& var, int n=1, int stride=sizeof(char))
{
    _IwSerialiseBitDepthRequired<char, true>(var, n, stride, IwSerialiseChar);
}
# 467 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseInt8BitDepthRequired(int8& var, int n=1, int stride=sizeof(int8))
{
    _IwSerialiseBitDepthRequired<int8, true>(var, n, stride, IwSerialiseInt8);
}
# 483 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseUInt8BitDepthRequired(uint8& var, int n=1, int stride=sizeof(uint8))
{
    _IwSerialiseBitDepthRequired<uint8, false>(var, n, stride, IwSerialiseUInt8);
}
# 499 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseInt16BitDepthRequired(int16& var, int n=1, int stride=sizeof(int16))
{
    _IwSerialiseBitDepthRequired<int16, true>(var, n, stride, IwSerialiseInt16);
}
# 515 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseUInt16BitDepthRequired(uint16& var, int n=1, int stride=sizeof(uint16))
{
    _IwSerialiseBitDepthRequired<uint16, false>(var, n, stride, IwSerialiseUInt16);
}
# 531 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseInt32BitDepthRequired(int32& var, int n=1, int stride=sizeof(int32))
{
    _IwSerialiseBitDepthRequired<int32, true>(var, n, stride, IwSerialiseInt32);
}
# 547 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseUInt32BitDepthRequired(uint32& var, int n=1, int stride=sizeof(uint32))
{
    _IwSerialiseBitDepthRequired<uint32, false>(var, n, stride, IwSerialiseUInt32);
}
# 602 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
void IwSerialiseMappedData(const uint16* pMap, void* _pData, int numStructs, int stride);
# 613 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
void IwSerialiseString(char* text, int maxLen=0);
# 626 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
void IwSerialiseManagedHash(void* pptr);






void IwSerialiseManagedObject(CIwManaged*& pObj);
# 644 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
void IwSerialiseFile(CIwTextParserITX* pParser, char const* filename, void* pptr, IwSerialiseMode mode);
# 653 "c:/marmalade/7.5/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseFile(CIwTextParserITX* pParser, char const* filename, void* pptr, bool read)
{
    IwSerialiseFile(pParser, filename, pptr, read ? IW_SERIALISE_READ : IW_SERIALISE_WRITE);
}
# 29 "c:/marmalade/7.5/modules/iwutil/h/IwString.h" 2
# 74 "c:/marmalade/7.5/modules/iwutil/h/IwString.h"
template <int N>
class CIwString
{


public:
    inline CIwString()
    {
        m_Buffer[0] = '\0';
    };

    CIwString(const char* pText)
    {
        m_Buffer[0] = '\0';
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(strlen(pText) < N)) && (IwDebugAssertIsChannelOn("CORE")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(276); IwDebugAssertSetMessage ("String '%s' too long - maximum size (including terminator character) is %d characters", pText, N); switch (IwDebugAssertShow("strlen(pText) < N", "c:/marmalade/7.5/modules/iwutil/h/IwString.h", 88, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do { if (s3eDebugIsDebuggerPresent()) __asm__ (" int $3 "); } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        strcpy(m_Buffer, pText);
    };
# 104 "c:/marmalade/7.5/modules/iwutil/h/IwString.h"
    inline const char* c_str() const {return m_Buffer;}
# 113 "c:/marmalade/7.5/modules/iwutil/h/IwString.h"
    inline int size() const {return (int)strlen(m_Buffer);}
# 122 "c:/marmalade/7.5/modules/iwutil/h/IwString.h"
    inline int length() const {return (int)strlen(m_Buffer);}






    inline int capacity() const {return N-1;}






    inline void setLength(int len)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(len >= 0)) && (IwDebugAssertIsChannelOn("CORE")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(277); IwDebugAssertSetMessage ("Length must be >= 0"); switch (IwDebugAssertShow("len >= 0", "c:/marmalade/7.5/modules/iwutil/h/IwString.h", 138, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do { if (s3eDebugIsDebuggerPresent()) __asm__ (" int $3 "); } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(len < N)) && (IwDebugAssertIsChannelOn("CORE")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(278); IwDebugAssertSetMessage ("Length too long - maximum size (including terminator character) is %d characters", N); switch (IwDebugAssertShow("len < N", "c:/marmalade/7.5/modules/iwutil/h/IwString.h", 139, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do { if (s3eDebugIsDebuggerPresent()) __asm__ (" int $3 "); } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        m_Buffer[len] = '\0';
    }

    inline int find(const char* substr)
    {
        char*p = strstr(m_Buffer, substr);
        if (p)
            return (int)(p - m_Buffer);
        return -1;
    }

    inline CIwString substr(int pos, int len = -1) const
    {
        if (len < 0)
            len = length() - pos;

        CIwString s(m_Buffer + pos);
        s.setLength(len);
        return s;
    }

    inline char & operator [] (int i)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(i >= 0)) && (IwDebugAssertIsChannelOn("CORE")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(279); IwDebugAssertSetMessage ("Index must be >= 0"); switch (IwDebugAssertShow("i >= 0", "c:/marmalade/7.5/modules/iwutil/h/IwString.h", 163, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do { if (s3eDebugIsDebuggerPresent()) __asm__ (" int $3 "); } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(i < length())) && (IwDebugAssertIsChannelOn("CORE")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(280); IwDebugAssertSetMessage ("Index is %d, but length of string is only %d characters", i, length()); switch (IwDebugAssertShow("i < length()", "c:/marmalade/7.5/modules/iwutil/h/IwString.h", 164, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do { if (s3eDebugIsDebuggerPresent()) __asm__ (" int $3 "); } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        return m_Buffer[i];
    }

    inline const char & operator [] (int i) const
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(i >= 0)) && (IwDebugAssertIsChannelOn("CORE")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(281); IwDebugAssertSetMessage ("Index must be >= 0"); switch (IwDebugAssertShow("i >= 0", "c:/marmalade/7.5/modules/iwutil/h/IwString.h", 170, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do { if (s3eDebugIsDebuggerPresent()) __asm__ (" int $3 "); } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(i < length())) && (IwDebugAssertIsChannelOn("CORE")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(282); IwDebugAssertSetMessage ("Index is %d, but length of string is only %d characters", i, length()); switch (IwDebugAssertShow("i < length()", "c:/marmalade/7.5/modules/iwutil/h/IwString.h", 171, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do { if (s3eDebugIsDebuggerPresent()) __asm__ (" int $3 "); } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        return m_Buffer[i];
    }






    const char* operator = (const char* pText)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(strlen(pText) < N)) && (IwDebugAssertIsChannelOn("CORE")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(283); IwDebugAssertSetMessage ("String '%s' too long - maximum size (including terminator character) is %d characters", pText, N); switch (IwDebugAssertShow("strlen(pText) < N", "c:/marmalade/7.5/modules/iwutil/h/IwString.h", 182, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do { if (s3eDebugIsDebuggerPresent()) __asm__ (" int $3 "); } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        strcpy(m_Buffer, pText);
        return m_Buffer;
    };

    const char* operator = ( CIwString const& str)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(str.length() < N)) && (IwDebugAssertIsChannelOn("CORE")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(284); IwDebugAssertSetMessage ("String '%s' too long - maximum size (including terminator character) is %d characters", str.c_str(), N); switch (IwDebugAssertShow("str.length() < N", "c:/marmalade/7.5/modules/iwutil/h/IwString.h", 189, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do { if (s3eDebugIsDebuggerPresent()) __asm__ (" int $3 "); } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        strcpy(m_Buffer, str.c_str());
        return m_Buffer;
    };

    const char* operator += (const char* pText)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(strlen(m_Buffer) + strlen(pText) < N)) && (IwDebugAssertIsChannelOn("CORE")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(285); IwDebugAssertSetMessage ("Combined string '%s%s' too long - maximum size (including terminator character) is %d characters", m_Buffer, pText, N); switch (IwDebugAssertShow("strlen(m_Buffer) + strlen(pText) < N", "c:/marmalade/7.5/modules/iwutil/h/IwString.h", 196, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do { if (s3eDebugIsDebuggerPresent()) __asm__ (" int $3 "); } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        strcat(m_Buffer, pText);
        return m_Buffer;
    };

    const char* operator += (CIwString const& str)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(strlen(m_Buffer) + str.length() < N)) && (IwDebugAssertIsChannelOn("CORE")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(286); IwDebugAssertSetMessage ("Combined string '%s%s' too long - maximum size (including terminator character) is %d characters", m_Buffer, str.c_str(), N); switch (IwDebugAssertShow("strlen(m_Buffer) + str.length() < N", "c:/marmalade/7.5/modules/iwutil/h/IwString.h", 203, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do { if (s3eDebugIsDebuggerPresent()) __asm__ (" int $3 "); } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        strcat(m_Buffer, str.c_str());
        return m_Buffer;
    };

    CIwString operator + (const char* pText)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(strlen(m_Buffer) + strlen(pText) < N)) && (IwDebugAssertIsChannelOn("CORE")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(287); IwDebugAssertSetMessage ("Combined string '%s%s' too long - maximum size (including terminator character) is %d characters", m_Buffer, pText, N); switch (IwDebugAssertShow("strlen(m_Buffer) + strlen(pText) < N", "c:/marmalade/7.5/modules/iwutil/h/IwString.h", 210, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do { if (s3eDebugIsDebuggerPresent()) __asm__ (" int $3 "); } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        CIwString ns = *this;
        strcat(ns.m_Buffer, pText);
        return ns;
    }

    CIwString operator + (const CIwString& str)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(strlen(m_Buffer) + str.length() < N)) && (IwDebugAssertIsChannelOn("CORE")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(288); IwDebugAssertSetMessage ("Combined string '%s%s' too long - maximum size (including terminator character) is %d characters", m_Buffer, str.c_str(), N); switch (IwDebugAssertShow("strlen(m_Buffer) + str.length() < N", "c:/marmalade/7.5/modules/iwutil/h/IwString.h", 218, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do { if (s3eDebugIsDebuggerPresent()) __asm__ (" int $3 "); } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        CIwString ns = *this;
        strcat(ns.m_Buffer, str.c_str());
        return ns;
    }

    const char* operator += (char c)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(strlen(m_Buffer) + 1 < N)) && (IwDebugAssertIsChannelOn("CORE")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(289); IwDebugAssertSetMessage ("String '%s%c' too long - maximum size (including terminator character) is %d characters", m_Buffer, c, N); switch (IwDebugAssertShow("strlen(m_Buffer) + 1 < N", "c:/marmalade/7.5/modules/iwutil/h/IwString.h", 226, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do { if (s3eDebugIsDebuggerPresent()) __asm__ (" int $3 "); } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        char str[2] = {c, '\0'};
        strcat(m_Buffer, str);
        return m_Buffer;
    };

    bool operator== (const char* str) const
    {
        return !strcmp(m_Buffer, str);
    }

    bool operator== (const CIwString& str) const
    {
        return !strcmp(m_Buffer, str.c_str());
    }






    inline void Serialise()
    {
        IwSerialiseString(m_Buffer, N);
    }


private:
    char m_Buffer[N];
};

template <int N>
static inline CIwString<N> operator + (const char *str1, const CIwString<N> &str2)
{
    return CIwString<N>(str1) + str2;
}






typedef CIwString<32> CIwStringS;




typedef CIwString<160> CIwStringL;
# 18 "c:/marmalade/7.5/modules/iwutil/h/IwHashString.h" 2

# 1 "c:/marmalade/7.5/modules/iwutil/h/IwRuntime.h" 1
       
# 30 "c:/marmalade/7.5/modules/iwutil/h/IwRuntime.h"
# 1 "c:/marmalade/7.5/s3e/h/s3eTimer.h" 1
# 55 "c:/marmalade/7.5/s3e/h/s3eTimer.h"
typedef enum s3eTimerProperty
{
    S3E_TIMER_RESOLUTION
} s3eTimerProperty;
# 67 "c:/marmalade/7.5/s3e/h/s3eTimer.h"
typedef enum s3eTimerError
{
    S3E_TIMER_ERR_NONE = 0,
    S3E_TIMER_ERR_PARAM = 1,
    S3E_TIMER_ERR_TOO_MANY = 2,
    S3E_TIMER_ERR_ALREADY_REG = 3,
    S3E_TIMER_ERR_NOT_FOUND = 4,
    S3E_TIMER_ERR_UNAVAIL = 5
} s3eTimerError;
# 88 "c:/marmalade/7.5/s3e/h/s3eTimer.h"
extern "C" s3eTimerError s3eTimerGetError();
# 101 "c:/marmalade/7.5/s3e/h/s3eTimer.h"
extern "C" const char* s3eTimerGetErrorString();
# 117 "c:/marmalade/7.5/s3e/h/s3eTimer.h"
extern "C" int32 s3eTimerGetInt(s3eTimerProperty property);
# 131 "c:/marmalade/7.5/s3e/h/s3eTimer.h"
extern "C" int64 s3eTimerGetUST();
# 142 "c:/marmalade/7.5/s3e/h/s3eTimer.h"
extern "C" int64 s3eTimerGetUSTNanoseconds();




extern "C" uint64 s3eTimerGetMs();





extern "C" int64 s3eTimerGetUTC();
# 162 "c:/marmalade/7.5/s3e/h/s3eTimer.h"
extern "C" int64 s3eTimerGetLocaltimeOffset(int64* when =__null);
# 194 "c:/marmalade/7.5/s3e/h/s3eTimer.h"
extern "C" s3eResult s3eTimerSetTimer(uint32 ms, s3eCallback fn, void* userData);
# 215 "c:/marmalade/7.5/s3e/h/s3eTimer.h"
extern "C" s3eResult s3eTimerCancelTimer(s3eCallback fn, void* userData);
# 31 "c:/marmalade/7.5/modules/iwutil/h/IwRuntime.h" 2

extern "C" {
# 41 "c:/marmalade/7.5/modules/iwutil/h/IwRuntime.h"
typedef struct _IwCallStack
{
    const char** m_Stack;
    const char** m_StackPtr;

} IwCallStack;

void IwCallStackLeave(void* pObj);
void IwCallStackSetStackSizeLimit(uint32 limit);
void IwCallStackSetStackAddress(uint32 addr);
void IwCallStackPrintStack(char* pBuffer);
IwCallStack* IwCallStackGet();







void IwCallStackInit();
void IwCallStackTerm();


s3eBool IwCallStackEnter(const char* pName, void* pObj);




void IwCallStackFunctionDumpToFile(const char* filename);





    void IwCallStackSetCallStackTracing(bool bOnOrOff);



void IwProfileStartProfile(const char* name);
void IwProfileStopProfile();
void IwProfileIncrementFrameCounter();
void IwProfileReset();

}
# 93 "c:/marmalade/7.5/modules/iwutil/h/IwRuntime.h"
class CIwCallStack
{
public:

    CIwCallStack(const char* pName)
    {
        m_Entered = IwCallStackEnter(pName, (void*)this);
    }
    ~CIwCallStack()
    {
        if( m_Entered )
            IwCallStackLeave((void*)this);
    }
    s3eBool m_Entered;
};
# 214 "c:/marmalade/7.5/modules/iwutil/h/IwRuntime.h"
class CIwProfileNode
{
public:
    CIwProfileNode(const char* name, CIwProfileNode* parent);
    ~CIwProfileNode();

    CIwProfileNode* GetSubNode(const char* name);

    CIwProfileNode* GetParent() {return m_Parent;}
    CIwProfileNode* GetSibling() {return m_Sibling;}
    CIwProfileNode* GetChild() {return m_Child;}

    void Reset();
    void Call();
    bool Return();
    void NewFrame();

    const char* GetName() {return m_Name;}
    long GetTotalCalls() {return m_TotalCalls;}
    float GetTotalTime() {return m_TotalTime;}
    float GetLastTime() {return m_LastTime;}

    long GetLastFrameCalls(){ return m_LastFrameCalls; }
    float GetLastFrameTime() { return m_LastFrameTime; }
    float GetFrameTimeAvg() { return m_FrameWeightedAvg; }

    bool IsRemainingTimeNode() { return m_IsOtherTimeNode; }

protected:
    const char* m_Name;
    long m_TotalCalls;
    float m_TotalTime;
    float m_LastTime;
    float m_WeightedAvg;

    long m_FrameCalls;
    float m_FrameTime;
    float m_FrameWeightedAvg;

    long m_LastFrameCalls;
    float m_LastFrameTime;

    int32 m_StartTime;
    long m_RecursionCounter;

    bool m_IsOtherTimeNode;

    CIwProfileNode* m_Parent;
    CIwProfileNode* m_Child;
    CIwProfileNode* m_Sibling;
};




class CIwProfileIterator
{
public:

    void First();
    void Next();
    bool IsDone();

    void EnterChild(long index);
    void EnterParent();


    const char* GetCurrentName() {return m_CurrentChild->GetName();}
    long GetCurrentTotalCalls() {return m_CurrentChild->GetTotalCalls();}
    float GetCurrentTotalTime() {return m_CurrentChild->GetTotalTime();}
    float GetCurrentLastTime() {return m_CurrentChild->GetLastTime();}
    float GetCurrentLastFrameTime() {return m_CurrentChild->GetLastFrameTime();}
    long GetCurrentLastFrameCalls() {return m_CurrentChild->GetLastFrameCalls();}
    float GetCurrentFrameTimeAvg() {return m_CurrentChild->GetFrameTimeAvg();}
    bool IsCurrentRemainingTimeNode() {return m_CurrentChild->IsRemainingTimeNode();}




    const char* GetCurrentParentName() {return m_CurrentParent->GetName();}
    long GetCurrentParentTotalCalls() {return m_CurrentParent->GetTotalCalls();}
    float GetCurrentParentTotalTime() {return m_CurrentParent->GetTotalTime();}


protected:
    CIwProfileNode* m_CurrentParent;
    CIwProfileNode* m_CurrentChild;

    CIwProfileIterator(CIwProfileNode* start);
    friend class CIwProfileManager;
};




class CIwProfileManager
{
public:
    CIwProfileManager(uint32 maxNodes=200);
    ~CIwProfileManager();

    inline void SetActive(bool active) {m_Active = active;}
    void StartProfile(const char* name);
    void StopProfile();

    void Reset();
    void IncrementFrameCounter();
    inline long GetFrameCountSinceReset() {return m_FrameCounter;}
    float GetTimeSinceReset();

    inline CIwProfileIterator* GetIterator() {return new CIwProfileIterator(&m_Root);}
    inline void ReleaseIterator(CIwProfileIterator* iterator ) {delete iterator;}


    static CIwProfileManager& Get();

    static CIwProfileManager* g_Singleton;

    CIwProfileNode* AllocNode(const char* name, CIwProfileNode* parent);

private:
    bool m_Active;
    CIwProfileNode m_Root;
    CIwProfileNode* m_CurrentNode;
    long m_FrameCounter;
    int64 m_ResetTime;
    uint32* m_Memory;
    uint32* m_MemoryCursor;
    int32 m_FreeNodes;
};




class CIwProfileSample
{
public:
    CIwProfileSample(const char* name) {IwProfileStartProfile(name);}
    ~CIwProfileSample() {IwProfileStopProfile();}
};
# 20 "c:/marmalade/7.5/modules/iwutil/h/IwHashString.h" 2
# 40 "c:/marmalade/7.5/modules/iwutil/h/IwHashString.h"
uint32 IwHashString(const char* pChar);
# 49 "c:/marmalade/7.5/modules/iwutil/h/IwHashString.h"
template<int N> uint32 IwHashString(const CIwString<N>& sz)
{
    CIwCallStack _callstack("IwHashString"); {}

    return IwHashString(sz.c_str());
}
# 65 "c:/marmalade/7.5/modules/iwutil/h/IwHashString.h"
uint32 IwHashString(const char* pChar, uint32 hash);
# 15 "c:/Marmalade/7.5/examples/GameTutorial/CPP/Stage4/source/timer.cpp" 2

Timer::Timer(float length, int repeat_count, Callback on_timeout, void* user_data) : m_Manager(0)
{
    m_Length = length;
    m_TimeLeft = length;
    m_OnTimeout = on_timeout;
    m_UserData = user_data;
    m_RepeatCount = repeat_count;
    m_Paused = false;
}

bool Timer::Update(float deltaTime)
{
    if (m_Paused)
        return false;

    m_TimeLeft -= deltaTime;
    if (m_TimeLeft <= 0)
    {
        if (m_OnTimeout != 0)
            m_OnTimeout(this, m_UserData);
        if (m_RepeatCount > 0)
        {
            m_RepeatCount--;
            if (m_RepeatCount == 0)
                return true;
        }
        m_TimeLeft += m_Length;
    }

    return false;
}

void Timer::Pause()
{
    m_Paused = true;
}

void Timer::Resume()
{
    m_Paused = false;
}


TimerManager::TimerManager()
{
}

TimerManager::~TimerManager()
{
    for (_STL::list<Timer*>::iterator it = m_Timers.begin(); it != m_Timers.end(); ++it)
        delete *it;
}

void TimerManager::Update(float deltaTime)
{
    for (_STL::list<Timer*>::iterator it = m_Timers.begin(); it != m_Timers.end(); ++it)
    {
        if ((*it)->Update(deltaTime))
        {
            delete *it;
            it = m_Timers.erase(it);
        }
    }
}

void TimerManager::Add(Timer* timer)
{
    m_Timers.push_back(timer);
    timer->setManager(this);
}

void TimerManager::Cancel(Timer* timer)
{
    m_Timers.remove(timer);
}

void TimerManager::Clear()
{
    for (_STL::list<Timer*>::iterator it = m_Timers.begin(); it != m_Timers.end(); ++it)
        delete *it;
    m_Timers.clear();
}

Timer* TimerManager::Find(const char* name)
{
    unsigned int name_hash = IwHashString(name);
    for (_STL::list<Timer*>::iterator it = m_Timers.begin(); it != m_Timers.end(); ++it)
    {
        if ((*it)->getNameHash() == name_hash)
            return *it;
    }

    return __null;
}

void TimerManager::Pause()
{
    for (_STL::list<Timer*>::iterator it = m_Timers.begin(); it != m_Timers.end(); ++it)
        (*it)->Pause();
}

void TimerManager::Resume()
{
    for (_STL::list<Timer*>::iterator it = m_Timers.begin(); it != m_Timers.end(); ++it)
        (*it)->Resume();
}
